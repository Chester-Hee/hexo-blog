<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>追赶日落日出</title>
  <icon>https://www.gravatar.com/avatar/7332532c35204b7ffa837ec218207b84</icon>
  <subtitle>何凌枫</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/"/>
  <updated>2019-08-19T02:25:51.363Z</updated>
  <id>https://xuehui.我爱你/</id>
  
  <author>
    <name>helingfeng</name>
    <email>dreamhelingfeng@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>POST 请求 application/x-www-form-urlencoded 与 multipart/form-data 区别</title>
    <link href="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/2019-08-10/form-content-types/"/>
    <id>https://xuehui.我爱你/2019-08-10/form-content-types/</id>
    <published>2019-08-10T07:55:00.000Z</published>
    <updated>2019-08-19T02:25:51.363Z</updated>
    
    <content type="html"><![CDATA[<p>如何正确选择 <code>Form</code> 的 <code>Content-type</code> 类型？</p><ul><li><ol><li><code>application/x-www-form-urlencoded</code>，表单默认的 <code>Content-type</code> 类型，支持 <code>ASCII</code> 的 <code>text</code> 文本内容</li></ol></li><li><ol start="2"><li><code>multipart/form-data</code>，允许提交表单包含： <code>files</code>，<code>non-ASCII</code>，<code>Binary</code></li></ol></li><li><ol start="3"><li><code>Row</code>，用于发送纯文本，或 <code>JSON</code> ，或其他类型字符串，客户端不会对数据做任何的修改</li></ol></li><li><ol start="4"><li><code>Binary</code>，用于请求需要附带非文本的数据，比如 <code>video/audio</code> 或者 <code>images</code> 或者其他 <code>Binary</code> 数据文件</li></ol></li></ul><h2 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a>application/x-www-form-urlencoded</h2><p>当表单使用 <code>application/x-www-form-urlencoded</code> 时，需要对参数进行<code>urlencode 编码</code>和<code>序列化</code></p><p>如，表单提交参数（key-value）为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">param1:website</span><br><span class="line">param2:https://www.google.com</span><br></pre></td></tr></table></figure></p><p>经过 <code>urlencode</code> 编码后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">param1:website</span><br><span class="line">param2:https%3A%2F%2Fwww.google.com</span><br></pre></td></tr></table></figure><p>再经过序列化，得到结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">param1=website&amp;param2=https%3A%2F%2Fwww.google.com</span><br></pre></td></tr></table></figure><h2 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h2><p>一个 <code>multipart/form-data</code> 消息体，包含多个块组成，每个块代表一个有效的表单控件，并使用 <code>boundary</code> 的字符串分割：</p><ul><li><ol><li>第一部分，<code>Content-Disposition: form-data</code> 参数名称，如，<code>name=&quot;my_control</code></li></ol></li><li><ol start="2"><li>第二部分，<code>Content-Type: text/plain</code></li></ol></li></ul><p>例如表单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;FORM action=&quot;http://server.com/cgi/handle&quot;</span><br><span class="line">       enctype=&quot;multipart/form-data&quot;</span><br><span class="line">       method=&quot;post&quot;&gt;</span><br><span class="line">   &lt;P&gt;</span><br><span class="line">   What is your name? &lt;INPUT type=&quot;text&quot; name=&quot;submit-name&quot;&gt;&lt;BR&gt;</span><br><span class="line">   What files are you sending? &lt;INPUT type=&quot;file&quot; name=&quot;files&quot;&gt;&lt;BR&gt;</span><br><span class="line">   &lt;INPUT type=&quot;submit&quot; value=&quot;Send&quot;&gt;</span><br><span class="line">   &lt;INPUT type=&quot;reset&quot;&gt;</span><br><span class="line">&lt;/FORM&gt;</span><br></pre></td></tr></table></figure><p>假设，<code>submit-name</code> 输入 <code>Larry</code> 文本，<code>files</code> 选择文件 <code>file1.txt</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=AaB03x</span><br><span class="line"></span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name=&quot;submit-name&quot;</span><br><span class="line"></span><br><span class="line">Larry</span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name=&quot;files&quot;; filename=&quot;file1.txt&quot;</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">... contents of file1.txt ...</span><br><span class="line">--AaB03x--</span><br></pre></td></tr></table></figure><p>参考文献：<a href="https://www.w3.org/TR/html401/interact/forms.html#h-17.13.4" target="_blank" rel="noopener">https://www.w3.org/TR/html401/interact/forms.html#h-17.13.4</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如何正确选择 &lt;code&gt;Form&lt;/code&gt; 的 &lt;code&gt;Content-type&lt;/code&gt; 类型？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;，表单默认的 &lt;code
      
    
    </summary>
    
      <category term="HTTP" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/categories/HTTP/"/>
    
    
      <category term="POST" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/POST/"/>
    
  </entry>
  
  <entry>
    <title>SSH 远程自动登录脚本</title>
    <link href="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/2019-07-10/ssh-remote-automatic-login-script/"/>
    <id>https://xuehui.我爱你/2019-07-10/ssh-remote-automatic-login-script/</id>
    <published>2019-07-10T07:55:00.000Z</published>
    <updated>2019-07-10T08:50:57.361Z</updated>
    
    <content type="html"><![CDATA[<p>我们使用过 <code>SSH</code> 远程登录一台服务器，登录需要输入用户名和密码，并且服务器密码一般很难靠脑记住；<code>Windows</code> 用户可以使用 <code>XShell</code> 这种强大的工具，但是 Linux 或者 Mac 用户更倾向于命令行自动化脚本。</p><p>开源的 <code>autossh</code> 工具，就为解决这个问题，使用 expect 工具完成交互，自动根据配置用户名密码登录指定服务器。</p><h3 id="安装-expect-工具"><a href="#安装-expect-工具" class="headerlink" title="安装 expect 工具"></a>安装 expect 工具</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Linux:</span><br><span class="line">$ yum install expect</span><br><span class="line">$ apt-get install expect</span><br><span class="line"></span><br><span class="line">Mac:</span><br><span class="line">$ brew install expect</span><br></pre></td></tr></table></figure><h3 id="安装-autossh-命令"><a href="#安装-autossh-命令" class="headerlink" title="安装 autossh 命令"></a>安装 autossh 命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/FeeiCN/autossh.git</span><br><span class="line">$ sudo cp autossh/autossh /usr/local/bin/</span><br></pre></td></tr></table></figure><h3 id="更新配置文件"><a href="#更新配置文件" class="headerlink" title="更新配置文件"></a>更新配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.autosshrc</span><br><span class="line"></span><br><span class="line">添加服务器配置，如下格式：</span><br><span class="line">server_name|192.168.1.110|root|password|port|is_bastion</span><br></pre></td></tr></table></figure><h3 id="远程登录服务器命令"><a href="#远程登录服务器命令" class="headerlink" title="远程登录服务器命令"></a>远程登录服务器命令</h3><p>输入 <code>autossh</code> 并选择需要登录的服务器编号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ autossh</span><br><span class="line">############################################################ </span><br><span class="line">#                     [AUTO SSH]                           # </span><br><span class="line">#                                                          # </span><br><span class="line">#                                                          # </span><br><span class="line"># [1] www.my-server.com - 192.168.192.110:root             # </span><br><span class="line">#                                                          # </span><br><span class="line">#                                                          # </span><br><span class="line">############################################################ </span><br><span class="line">Server Number: 1</span><br></pre></td></tr></table></figure></p><h3 id="如果自己也想写一个-SSH-自动登录脚本"><a href="#如果自己也想写一个-SSH-自动登录脚本" class="headerlink" title="如果自己也想写一个 SSH 自动登录脚本"></a>如果自己也想写一个 SSH 自动登录脚本</h3><p>可以直接使用 expect 工具，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/expect</span><br><span class="line"></span><br><span class="line">spawn ssh root@192.168.192.110</span><br><span class="line">expect &quot;password:&quot;</span><br><span class="line"></span><br><span class="line">send &quot;12345678.\r&quot;</span><br></pre></td></tr></table></figure><blockquote><p>先推荐一款 <code>WEB</code> 流程图在线编辑工具：<a href="https://www.draw.io" target="_blank" rel="noopener">https://www.draw.io</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们使用过 &lt;code&gt;SSH&lt;/code&gt; 远程登录一台服务器，登录需要输入用户名和密码，并且服务器密码一般很难靠脑记住；&lt;code&gt;Windows&lt;/code&gt; 用户可以使用 &lt;code&gt;XShell&lt;/code&gt; 这种强大的工具，但是 Linux 或者 Mac 用户更
      
    
    </summary>
    
      <category term="Linux" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/categories/Linux/"/>
    
    
      <category term="SSH" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>前端JS压缩图片，并解决旋转问题</title>
    <link href="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/2019-06-26/use-javascript-compressed-pictures/"/>
    <id>https://xuehui.我爱你/2019-06-26/use-javascript-compressed-pictures/</id>
    <published>2019-06-26T12:00:00.000Z</published>
    <updated>2019-06-27T02:59:28.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-压缩图片"><a href="#JavaScript-压缩图片" class="headerlink" title="JavaScript 压缩图片"></a>JavaScript 压缩图片</h2><p>☘️WEB前端上传文件到远程时，我们都会遇到同样一个问题，请求长度超出限制，是的，<strong>文件大小超出限制</strong>该如何解决？</p><p>我这里有两种方案：</p><ul><li>第一种，<strong>前端压缩</strong>后上传图片</li><li>第二种，<strong>分块上传</strong>，后台进行压缩存储</li><li>其实有第三种，不允许上传此文件 😅</li></ul><p>如果只考虑第一种方案，前端压缩图片后上传，对于压缩图片的大小和质量无法把控，并且非图片类型的文件上传又要考虑非图片类型文件的压缩方法。<br>第二种方式，实现分块上传对编码要求更高，后端和前端都需要实现可靠的组件。</p><p>本篇文章，我们<strong>只了解如何使用前端压缩图片</strong></p><p>我画了一张图，大致描述前端压缩图片整个流程调用</p><p><img src="/images/demo11.jpg" alt="demo11"></p><p>使用 <code>JavaScript</code> 压缩图片，首先要学习三个<code>Web API</code>: <code>FileReader</code>，<code>Canvas</code>，<code>Blob</code></p><h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><p>FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。</p><p>成员方法：</p><ul><li><code>FileReader.abort()</code>中止读取操作。在返回时，<code>readyState</code>属性为<code>DONE</code>。</li><li><code>FileReader.readAsArrayBuffer()</code>开始读取指定的<code>Blob</code>中的内容, 一旦完成, <code>result</code> 属性中保存的将是被读取文件的 <code>ArrayBuffer</code> 数据对象.</li><li><code>FileReader.readAsBinaryString()</code>开始读取指定的Blob中的内容。一旦完成，result属性中将包含所读取文件的原始二进制数据。</li><li><code>FileReader.readAsDataURL()</code>开始读取指定的<code>Blob</code>中的内容。一旦完成，<code>result</code>属性中将包含一个<code>data: URL</code>格式的字符串以表示所读取文件的内容。</li><li><code>FileReader.readAsText()</code>开始读取指定的Blob中的内容。一旦完成，<code>result</code>属性中将包含一个字符串以表示所读取的文件内容。</li></ul><p>事件处理：</p><ul><li><code>FileReader.onabort</code>处理<code>abort</code>事件。该事件在读取操作被中断时触发。</li><li><code>FileReader.onerror</code>处理<code>error</code>事件。该事件在读取操作发生错误时触发。</li><li><code>FileReader.onload</code>处理<code>load</code>事件。该事件在读取操作完成时触发。</li><li><code>FileReader.onloadstart</code>处理<code>loadstart</code>事件。该事件在读取操作开始时触发。</li><li><code>FileReader.onloadend</code>处理<code>loadend</code>事件。该事件在读取操作结束时（要么成功，要么失败）触发。</li><li><code>FileReader.onprogress</code>处理<code>progress</code>事件。该事件在读取<code>Blob</code>时触发</li></ul><p>图片压缩过程中，我们需要使用到<code>FileReader.readAsDataURL()</code>将文件转换为<code>DataURL</code>，并使用<code>FileReader.onload</code>事件接收转换结果。</p><p>代码实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ready = <span class="keyword">new</span> FileReader();</span><br><span class="line">ready.readAsDataURL(file);</span><br><span class="line">ready.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> re = <span class="keyword">this</span>.result;</span><br><span class="line">    <span class="comment">// re 为 Base64 DataURL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><p>HTML5 <code>&lt;canvas&gt;</code> 标签用于绘制图像（通过脚本，通常是 JavaScript）。不过，<code>&lt;canvas&gt;</code> 元素本身并没有绘制能力（它仅仅是图形的容器） - 您必须使用脚本来完成实际的绘图任务。</p><ul><li>getContext() 方法可返回一个对象，该对象提供了用于在画布上绘图的方法和属性</li><li>getContext(“2d”) 对象属性和方法，可用于在画布上绘制文本、线条、矩形、圆形等等</li></ul><p><strong>drawImage</strong> drawImage() 方法在画布上绘制图像、画布或视频</p><p>三种重载方式：</p><ol><li><p>context.drawImage(img,x,y); // 在画布上定位图像</p></li><li><p>context.drawImage(img,x,y,width,height); // 在画布上定位图像，并规定图像的宽度和高度</p></li><li><p>context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height); // 剪切图像，并在画布上定位被剪切的部分</p></li></ol><p>图片裁剪过程中，我们将会使用第二种方式，压缩修改图片的大小（实现等比例缩放）</p><p>代码实现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.src = path;</span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 等比例缩放</span></span><br><span class="line">    <span class="keyword">var</span> w = that.width,</span><br><span class="line">        h = that.height,</span><br><span class="line">        scale = w / h;</span><br><span class="line">    w = obj.width || w;</span><br><span class="line">    h = obj.height || (w / scale);</span><br><span class="line">    <span class="keyword">var</span> quality = <span class="number">0.7</span>;</span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">    <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">    <span class="keyword">var</span> anw = <span class="built_in">document</span>.createAttribute(<span class="string">"width"</span>);</span><br><span class="line">    anw.nodeValue = w;</span><br><span class="line">    <span class="keyword">var</span> anh = <span class="built_in">document</span>.createAttribute(<span class="string">"height"</span>);</span><br><span class="line">    anh.nodeValue = h;</span><br><span class="line">    canvas.setAttributeNode(anw);</span><br><span class="line">    canvas.setAttributeNode(anh);</span><br><span class="line">    ctx.drawImage(that, <span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line">    <span class="keyword">if</span>(obj.quality &amp;&amp; obj.quality &lt;= <span class="number">1</span> &amp;&amp; obj.quality &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        quality = obj.quality;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> base64 = canvas.toDataURL(<span class="string">'image/jpeg'</span>, quality);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h3><p><code>Blob</code>对象表示一个不可变、原始数据的类文件对象。<code>Blob</code>表示的不一定是<code>JavaScript</code>原生格式的数据。<code>File</code>接口基于<code>Blob</code>，继承了<code>blob</code>的功能并将其扩展使其支持用户系统上的文件。</p><p>要从其他非<code>blob</code>对象和数据构造一个<code>Blob</code>，请使用<code>Blob()</code>构造函数。要创建包含另一个<code>blob</code>数据的子集<code>blob</code>，请使用<code>slice()</code>方法。</p><p>此处 <code>slice()</code> 也是用于分块上传的调用方法</p><p>本文前端压缩图片流程，我们只需要用到<code>Blob()</code>构造函数</p><p>下面代码实现：DataURL 创建 Blob 对象，提供上传表单<code>form-data</code>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataURLtoFile</span>(<span class="params">dataurl, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = dataurl.split(<span class="string">','</span>), mime = arr[<span class="number">0</span>].match(<span class="regexp">/:(.*?);/</span>)[<span class="number">1</span>],</span><br><span class="line">    bstr = atob(arr[<span class="number">1</span>]), n = bstr.length, u8arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(n);</span><br><span class="line">  <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">    u8arr[n] = bstr.charCodeAt(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> File([u8arr], filename, &#123;<span class="attr">type</span>:mime&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图片拍摄角度问题"><a href="#图片拍摄角度问题" class="headerlink" title="图片拍摄角度问题"></a>图片拍摄角度问题</h3><p>首先来了解一个概念 <code>EXIF</code> 是什么?</p><p>简单来说，<code>Exif</code>信息就是由数码相机在拍摄过程中采集一系列的信息，然后把信息放置在我们熟知的<code>JPEG/TIFF</code>文件的头部，也就是说<code>Exif</code>信息是镶嵌在 <code>JPEG/TIFF</code>图像文件格式内的一组拍摄参数。主要包含了以下几类信息：</p><ul><li>拍摄日期</li><li>摄器材（机身、镜头、闪光灯等</li><li>拍摄参数（快门速度、光圈F值、ISO速度、焦距、测光模式等</li><li>图像处理参数（锐化、对比度、饱和度、白平衡等）</li><li>图像描述及版权信息</li><li>GPS定位数据</li><li>缩略图</li></ul><p>其中<code>orientation</code>记录着拍摄后图片旋转的角度信息：<a href="https://www.impulseadventure.com/photo/exif-orientation.html" target="_blank" rel="noopener">https://www.impulseadventure.com/photo/exif-orientation.html</a></p><table><thead><tr><th style="text-align:center">orientation</th><th style="text-align:center">旋转角度</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0°</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">180°</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">顺时针90°</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">逆时针90°</td></tr></tbody></table><p>所以，上传图片时，需要将图片进行反向旋转，才能得到一致的展示效果。</p><p>开始旋转图片之前，我们需要获取图片旋转信息，需要引入扩展：<a href="https://github.com/exif-js/exif-js" target="_blank" rel="noopener">https://github.com/exif-js/exif-js</a></p><p>然后，就可以编写代码实现：（所有的旋转都是以原点为中心的）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line"><span class="keyword">const</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">const</span> anw = <span class="built_in">document</span>.createAttribute(<span class="string">'width'</span>);</span><br><span class="line"><span class="keyword">const</span> anh = <span class="built_in">document</span>.createAttribute(<span class="string">'height'</span>);</span><br><span class="line">anw.nodeValue = w;</span><br><span class="line">anh.nodeValue = h;</span><br><span class="line"><span class="keyword">switch</span> (orientation) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">// 90度</span></span><br><span class="line">    anw.nodeValue = h;</span><br><span class="line">    anh.nodeValue = w;</span><br><span class="line">    canvas.setAttributeNode(anh);</span><br><span class="line">    canvas.setAttributeNode(anw);</span><br><span class="line">    ctx.rotate(<span class="built_in">Math</span>.PI / <span class="number">2</span>);</span><br><span class="line">    ctx.drawImage(<span class="keyword">this</span>, <span class="number">0</span>, -h, w, h);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// 180度</span></span><br><span class="line">    canvas.setAttributeNode(anh);</span><br><span class="line">    canvas.setAttributeNode(anw);</span><br><span class="line">    ctx.rotate(<span class="built_in">Math</span>.PI);</span><br><span class="line">    ctx.drawImage(<span class="keyword">this</span>, -w, -h, w, h);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">8</span>: <span class="comment">// -90度</span></span><br><span class="line">    anw.nodeValue = h;</span><br><span class="line">    anh.nodeValue = w;</span><br><span class="line">    canvas.setAttributeNode(anh);</span><br><span class="line">    canvas.setAttributeNode(anw);</span><br><span class="line">    ctx.rotate(<span class="number">3</span> * <span class="built_in">Math</span>.PI / <span class="number">2</span>);</span><br><span class="line">    ctx.drawImage(<span class="keyword">this</span>, -w, <span class="number">0</span>, w, h);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: <span class="comment">// 0度</span></span><br><span class="line">    canvas.setAttributeNode(anh);</span><br><span class="line">    canvas.setAttributeNode(anw);</span><br><span class="line">    ctx.drawImage(<span class="keyword">this</span>, <span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JavaScript-压缩图片&quot;&gt;&lt;a href=&quot;#JavaScript-压缩图片&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 压缩图片&quot;&gt;&lt;/a&gt;JavaScript 压缩图片&lt;/h2&gt;&lt;p&gt;☘️WEB前端上传文件到远程时，我们
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/JavaScript/"/>
    
      <category term="canvas" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>使用 Laravel-Swagger 编写接口文档</title>
    <link href="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/2019-05-25/use-laravel-swagger-writing-document/"/>
    <id>https://xuehui.我爱你/2019-05-25/use-laravel-swagger-writing-document/</id>
    <published>2019-05-25T09:00:00.000Z</published>
    <updated>2019-06-24T08:05:58.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Swagger-文档管理"><a href="#Swagger-文档管理" class="headerlink" title="Swagger 文档管理"></a>Swagger 文档管理</h2><p>官方网站：<a href="https://swagger.io/" target="_blank" rel="noopener">https://swagger.io/</a></p><p>快速编写你的 <code>RESTFUL API</code> 接口文档工具，通过注释定义接口和模型，可以和代码文件放置一起，也可以单独文件存放。</p><p><strong>优势</strong></p><ul><li>通过代码注解定义文档，更容易保持代码文档的一致性</li><li>模型复用，减少文档冗余，带来更可靠的文档</li><li>提供客户端访问接口，可以直接调试接口，不需要第三方工具进行调用测试接口</li><li>支持权限认证，等功能</li></ul><h3 id="Laravel-Swagger-扩展"><a href="#Laravel-Swagger-扩展" class="headerlink" title="Laravel Swagger 扩展"></a>Laravel Swagger 扩展</h3><p>扩展源代码地址：<a href="https://github.com/DarkaOnLine/L5-Swagger" target="_blank" rel="noopener">https://github.com/DarkaOnLine/L5-Swagger</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">composer require darkaonline/l5-swagger</span><br><span class="line">php artisan vendor:publish --provider "L5Swagger\L5SwaggerServiceProvider"</span><br></pre></td></tr></table></figure><p>将会生成配置文件 <code>l5-swagger.php</code>，其中需要注意的配置项</p><ul><li><code>routes.api</code> 默认值为 <code>api/documentation</code> Swagger 文档系统访问路由</li><li><code>routes.docs</code> Swagger 解析注释生成文档 JSON 文件的存储路径</li><li><code>paths.annotations</code> 有效注释的路径配置，默认 <code>base_path(&#39;app&#39;)</code> 应用路径</li><li><code>generate_always</code> 测试环境应该开启这个配置，每次访问都会自动解析注释生成最新的文档</li><li><code>swagger_version</code> 这个默认为 2.0 , 建议修改为 3.0</li></ul><p><strong>下文所有的注释内容，需要存在于 <code>paths.annotations</code> 路径下。</strong></p><h3 id="接口版本"><a href="#接口版本" class="headerlink" title="接口版本"></a>接口版本</h3><p><code>@OA\Info</code> 定义接口版本，标题，描述，已经作者信息。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@OA</span>\Info(</span></span><br><span class="line"><span class="comment"> *      version="1.0",</span></span><br><span class="line"><span class="comment"> *      title="用户管理",</span></span><br><span class="line"><span class="comment"> *      description="用户模块接口",</span></span><br><span class="line"><span class="comment"> *      <span class="doctag">@OA</span>\Contact(</span></span><br><span class="line"><span class="comment"> *          name="PHP 开发支持",</span></span><br><span class="line"><span class="comment"> *          email="dreamhelingfeng<span class="doctag">@gmail</span>.com"</span></span><br><span class="line"><span class="comment"> *      )</span></span><br><span class="line"><span class="comment"> * )</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="接口请求方式与请求路径"><a href="#接口请求方式与请求路径" class="headerlink" title="接口请求方式与请求路径"></a>接口请求方式与请求路径</h3><p><code>@OA\Get</code>,<code>@OA\Post</code> 定义接口请求方式</p><p>示例：根据<code>USER_ID</code>请求用户详情信息 <code>/api/users/{user_id}</code><br>接口分组配置：<code>tags</code>，将会对接口归类</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@OA</span>\Get(</span></span><br><span class="line"><span class="comment">  *   path="/api/users/&#123;user_id&#125;",</span></span><br><span class="line"><span class="comment">  *   summary="根据 ID 获取用户信息",</span></span><br><span class="line"><span class="comment">  *   tags=&#123;"用户管理"&#125;,</span></span><br><span class="line"><span class="comment">  *   <span class="doctag">@OA</span>\Parameter(</span></span><br><span class="line"><span class="comment">  *     name="user_id",</span></span><br><span class="line"><span class="comment">  *     in="path",</span></span><br><span class="line"><span class="comment">  *     required=true,</span></span><br><span class="line"><span class="comment">  *     description="用户 ID",</span></span><br><span class="line"><span class="comment">  *     <span class="doctag">@OA</span>\Schema(</span></span><br><span class="line"><span class="comment">  *        type="string"</span></span><br><span class="line"><span class="comment">  *     )</span></span><br><span class="line"><span class="comment">  *   ),</span></span><br><span class="line"><span class="comment">  *   <span class="doctag">@OA</span>\Response(</span></span><br><span class="line"><span class="comment">  *     response=200,</span></span><br><span class="line"><span class="comment">  *     description="用户对象",</span></span><br><span class="line"><span class="comment">  *     <span class="doctag">@OA</span>\JsonContent(ref="#/components/schemas/UserModel")</span></span><br><span class="line"><span class="comment">  *   )</span></span><br><span class="line"><span class="comment">  * )</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h3 id="接口请求参数"><a href="#接口请求参数" class="headerlink" title="接口请求参数"></a>接口请求参数</h3><p>通过 Swagger 可以定义三类参数，<code>path</code>,<code>header</code>,<code>query</code></p><ul><li>path, 参数存在 endponit 中，如，/users/{user_id}</li><li>header, 参数存在请求头部，如，token 用户校验令牌</li><li>query, 请求参数带在请求URL上，如，/users?nickname={nickname}</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@OA</span>\Get(</span></span><br><span class="line"><span class="comment">  *   <span class="doctag">@OA</span>\Parameter(</span></span><br><span class="line"><span class="comment">  *     name="user_id",</span></span><br><span class="line"><span class="comment">  *     in="path",</span></span><br><span class="line"><span class="comment">  *     required=true,</span></span><br><span class="line"><span class="comment">  *     description="用户 ID",</span></span><br><span class="line"><span class="comment">  *     <span class="doctag">@OA</span>\Schema(</span></span><br><span class="line"><span class="comment">  *        type="string"</span></span><br><span class="line"><span class="comment">  *     )</span></span><br><span class="line"><span class="comment">  * )</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><p>POST 提交表单，通常使用 <code>application/json</code> 方式，如，创建用户</p><p><code>@OA\Post</code><br>path=<code>/users</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *   <span class="doctag">@OA</span>\RequestBody(</span></span><br><span class="line"><span class="comment">  *       <span class="doctag">@OA</span>\MediaType(</span></span><br><span class="line"><span class="comment">  *           mediaType="application/json",</span></span><br><span class="line"><span class="comment">  *           <span class="doctag">@OA</span>\Schema(ref="#/components/schemas/UserModel"),</span></span><br><span class="line"><span class="comment">  *           example=&#123;</span></span><br><span class="line"><span class="comment">  *              "username": "helingfeng", "age": "25"</span></span><br><span class="line"><span class="comment">  *           &#125;</span></span><br><span class="line"><span class="comment">  *       )</span></span><br><span class="line"><span class="comment">  *   )</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h3 id="Schema-模型定义"><a href="#Schema-模型定义" class="headerlink" title="Schema 模型定义"></a>Schema 模型定义</h3><p>上面的注释中，多次引用 <code>@OA\Schema(ref=&quot;#/components/schemas/UserModel&quot;)</code> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@OA</span>\Schema(</span></span><br><span class="line"><span class="comment"> *      schema="UserModel",</span></span><br><span class="line"><span class="comment"> *      required=&#123;"username", "age"&#125;,</span></span><br><span class="line"><span class="comment"> *      <span class="doctag">@OA</span>\Property(</span></span><br><span class="line"><span class="comment"> *          property="username",</span></span><br><span class="line"><span class="comment"> *          type="string",</span></span><br><span class="line"><span class="comment"> *          description="用户名称"</span></span><br><span class="line"><span class="comment"> *      ),</span></span><br><span class="line"><span class="comment"> *      <span class="doctag">@OA</span>\Property(</span></span><br><span class="line"><span class="comment"> *          property="age",</span></span><br><span class="line"><span class="comment"> *          type="int",</span></span><br><span class="line"><span class="comment"> *          description="年龄"</span></span><br><span class="line"><span class="comment"> *      )</span></span><br><span class="line"><span class="comment"> * )</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>Laravel-Swagger 会自动根据您的注释进行匹配</p><h3 id="上传文件接口示例"><a href="#上传文件接口示例" class="headerlink" title="上传文件接口示例"></a>上传文件接口示例</h3><p>定义一个接口，接收上传文件，并返回结果远程文件地址</p><p><strong>接口定义：</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@OA</span>\Post(</span></span><br><span class="line"><span class="comment">  *   path="/api/files/upload",</span></span><br><span class="line"><span class="comment">  *   summary="文件上传",</span></span><br><span class="line"><span class="comment">  *   tags=&#123;"文件上传"&#125;,</span></span><br><span class="line"><span class="comment">  *   <span class="doctag">@OA</span>\RequestBody(</span></span><br><span class="line"><span class="comment">  *       <span class="doctag">@OA</span>\MediaType(</span></span><br><span class="line"><span class="comment">  *           mediaType="multipart/form-data",</span></span><br><span class="line"><span class="comment">  *           <span class="doctag">@OA</span>\Schema(</span></span><br><span class="line"><span class="comment">  *              required=&#123;"upload_file"&#125;,</span></span><br><span class="line"><span class="comment">  *              <span class="doctag">@OA</span>\Property(</span></span><br><span class="line"><span class="comment">  *                  property="upload_file",</span></span><br><span class="line"><span class="comment">  *                  type="file",</span></span><br><span class="line"><span class="comment">  *                  description="上传文件"</span></span><br><span class="line"><span class="comment">  *              ),</span></span><br><span class="line"><span class="comment">  *           ),</span></span><br><span class="line"><span class="comment">  *       )</span></span><br><span class="line"><span class="comment">  *   ),</span></span><br><span class="line"><span class="comment">  *   <span class="doctag">@OA</span>\Response(</span></span><br><span class="line"><span class="comment">  *     response=200,</span></span><br><span class="line"><span class="comment">  *     description="上传成功",</span></span><br><span class="line"><span class="comment">  *     <span class="doctag">@OA</span>\JsonContent(ref="#/components/schemas/UploadFileModel")</span></span><br><span class="line"><span class="comment">  *   ),</span></span><br><span class="line"><span class="comment">  *   <span class="doctag">@OA</span>\Response(</span></span><br><span class="line"><span class="comment">  *     response="default",</span></span><br><span class="line"><span class="comment">  *     description="error",</span></span><br><span class="line"><span class="comment">  *     <span class="doctag">@OA</span>\JsonContent(ref="#/components/schemas/ErrorModel")</span></span><br><span class="line"><span class="comment">  *   )</span></span><br><span class="line"><span class="comment">  * )</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure></p><p><strong>模型定义：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@OA</span>\Schema(</span></span><br><span class="line"><span class="comment"> *      schema="UploadFileModel",</span></span><br><span class="line"><span class="comment"> *      <span class="doctag">@OA</span>\Property(</span></span><br><span class="line"><span class="comment"> *          property="file_name",</span></span><br><span class="line"><span class="comment"> *          type="string",</span></span><br><span class="line"><span class="comment"> *          description="文件名，不包含路径"</span></span><br><span class="line"><span class="comment"> *      ),</span></span><br><span class="line"><span class="comment"> *      <span class="doctag">@OA</span>\Property(</span></span><br><span class="line"><span class="comment"> *          property="file_path",</span></span><br><span class="line"><span class="comment"> *          type="string",</span></span><br><span class="line"><span class="comment"> *          description="文件路径"</span></span><br><span class="line"><span class="comment"> *      ),</span></span><br><span class="line"><span class="comment"> *      <span class="doctag">@OA</span>\Property(</span></span><br><span class="line"><span class="comment"> *          property="file_url",</span></span><br><span class="line"><span class="comment"> *          type="string",</span></span><br><span class="line"><span class="comment"> *          description="URL链接，用于展示"</span></span><br><span class="line"><span class="comment"> *      ),</span></span><br><span class="line"><span class="comment"> *      <span class="doctag">@OA</span>\Property(</span></span><br><span class="line"><span class="comment"> *          property="file_size",</span></span><br><span class="line"><span class="comment"> *          type="string",</span></span><br><span class="line"><span class="comment"> *          description="文件大小，单位B"</span></span><br><span class="line"><span class="comment"> *      ),</span></span><br><span class="line"><span class="comment"> *      <span class="doctag">@OA</span>\Property(</span></span><br><span class="line"><span class="comment"> *          property="extension",</span></span><br><span class="line"><span class="comment"> *          type="string",</span></span><br><span class="line"><span class="comment"> *          description="文件扩展名"</span></span><br><span class="line"><span class="comment"> *      )</span></span><br><span class="line"><span class="comment"> * )</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>访问 <code>api/documentation</code> 效果如图</p><p><img src="/images/swagger-demo1.png" alt="demo1"></p><p><code>try it out</code> 上传文件操作结果</p><p><img src="/images/swagger-demo2.png" alt="demo2"></p><h3 id="需要权限认证的接口"><a href="#需要权限认证的接口" class="headerlink" title="需要权限认证的接口"></a>需要权限认证的接口</h3><p>一般对外网开放的接口，需要添加权限控制，Swagger 提供很好的支持</p><p>在 <code>l5-swagger.php</code> 配置文件中添加， <code>crypt-token</code> 定义请求头部必须添加 <code>token</code> 作为权限校验令牌。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'security'</span> =&gt; [</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    |--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">    | Examples of Security definitions</span></span><br><span class="line"><span class="comment">    |--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="string">'crypt-token'</span> =&gt; [ <span class="comment">// Unique name of security</span></span><br><span class="line">        <span class="string">'type'</span> =&gt; <span class="string">'apiKey'</span>, <span class="comment">// The type of the security scheme. Valid values are "basic", "apiKey" or "oauth2".</span></span><br><span class="line">        <span class="string">'description'</span> =&gt; <span class="string">'A short description for security scheme'</span>,</span><br><span class="line">        <span class="string">'name'</span> =&gt; <span class="string">'token'</span>, <span class="comment">// The name of the header or query parameter to be used.</span></span><br><span class="line">        <span class="string">'in'</span> =&gt; <span class="string">'header'</span>, <span class="comment">// The location of the API key. Valid values are "query" or "header".</span></span><br><span class="line">    ],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>接口注释中，添加对应的验证方式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * security=&#123;</span></span><br><span class="line"><span class="comment">  *    &#123;"crypt-token": &#123;&#125;&#125;</span></span><br><span class="line"><span class="comment">  * &#125;,</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><p><img src="/images/swagger-demo3.png" alt="demo3"></p><p>更多 Swagger3 定义字段描述，可以查看官方文档：<a href="https://swagger.io/specification/#parameterObject" target="_blank" rel="noopener">https://swagger.io/specification/#parameterObject</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Swagger-文档管理&quot;&gt;&lt;a href=&quot;#Swagger-文档管理&quot; class=&quot;headerlink&quot; title=&quot;Swagger 文档管理&quot;&gt;&lt;/a&gt;Swagger 文档管理&lt;/h2&gt;&lt;p&gt;官方网站：&lt;a href=&quot;https://swagger.
      
    
    </summary>
    
      <category term="PHP" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/PHP/"/>
    
      <category term="Laravel" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/Laravel/"/>
    
      <category term="swagger" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/swagger/"/>
    
  </entry>
  
  <entry>
    <title>Laravel 实现页面静态缓存</title>
    <link href="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/2019-05-24/laravel-implementing-static-page-caching/"/>
    <id>https://xuehui.我爱你/2019-05-24/laravel-implementing-static-page-caching/</id>
    <published>2019-05-24T09:30:00.000Z</published>
    <updated>2019-05-24T09:19:05.488Z</updated>
    
    <content type="html"><![CDATA[<h2 id="页面静态缓存"><a href="#页面静态缓存" class="headerlink" title="页面静态缓存"></a>页面静态缓存</h2><p>页面缓存就是在用户访问页面时，直接返回静态文件，减少了每次请求的业务处理和模板渲染，从而提高网站的<code>QPS</code>。在许多实时性要求不高的场景，或者纯查询和展示数据的页面，添加静态页面缓存并合理的配置缓存有效期可以有效的提升网站性能。</p><h2 id="Laravel-页面静态缓存"><a href="#Laravel-页面静态缓存" class="headerlink" title="Laravel 页面静态缓存"></a>Laravel 页面静态缓存</h2><p>附上代码地址：<a href="https://github.com/freedoomcode/laravel-page-cache" target="_blank" rel="noopener">https://github.com/freedoomcode/laravel-page-cache</a></p><p>我编码功底有限，希望你可以舍得给予建议</p><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ul><li>对于请求前后的处理，我们想到的是中间件（请求过滤器）</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">($request, Closure $next, $guard = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 请求之前处理</span></span><br><span class="line">    $response = $next($request);</span><br><span class="line">    <span class="comment">// 请求之后处理</span></span><br><span class="line">    <span class="keyword">return</span> $response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>请求之前，我们对请求参数<code>path</code>+<code>query</code>进行编码作为文件名</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$fileName = md5($uri);</span><br></pre></td></tr></table></figure><ul><li>并使用此文件名搜索是否存在文件，如果文件存在，若存在直接读取返回</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$fileName = <span class="keyword">$this</span>-&gt;getRealFileNameByPath($request-&gt;getRequestUri());</span><br><span class="line"><span class="keyword">if</span> (is_file($fileName)) &#123;</span><br><span class="line">    <span class="keyword">return</span> response(file_get_contents($fileName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>若不存在则将当期页面的响应内容写入文件，为了确保内容正确，判断响应状态码是否为<code>200</code>。并对正在写入的文件进行加锁。</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ($response-&gt;getStatusCode() == <span class="number">200</span>) &#123;</span><br><span class="line">    $content = $response-&gt;getContent();</span><br><span class="line">    <span class="keyword">if</span> (!is_file($fileName)) &#123;</span><br><span class="line">        file_put_contents($fileName, $content, LOCK_EX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分布式支持"><a href="#分布式支持" class="headerlink" title="分布式支持"></a>分布式支持</h3><p>起初，我想将整个页面文档存入<code>Redis</code>中，但测试发现导致<code>Redis</code>网络占用非常高，因为单个页面大小为<code>100K+</code>，同时访问将会不断读取<code>Redis</code>。最后，我将页面保存在服务器文件中。</p><p>但是，如果存在多台服务器，那么如何统一更新页面缓存呢？所以还需要共享一个键值，我将这个键值存储在<code>Redis</code>中，这个键值相当于每个服务存储静态文件的所在路径。更新这个键值就相当于更新文件所在路径。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$key = env(<span class="string">'STATIC_HTML_CACHE_DIR_KEY'</span>, <span class="string">'static_html_directory'</span>);</span><br><span class="line">$expires = env(<span class="string">'STATIC_HTML_CACHE_EXPIRE'</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span>(Cache::has($key)) &#123;</span><br><span class="line">    $directory = Cache::get($key, date(<span class="string">'YmdHis'</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $directory = date(<span class="string">'YmdHis'</span>);</span><br><span class="line">    Cache::put($key, $directory, $expires);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 完整的路径为 storage + directory</span></span><br><span class="line">$fullPath = $prefix . DIRECTORY_SEPARATOR . $directory;</span><br></pre></td></tr></table></figure><p>将文件存储在每台服务器中，均衡负载的压力，如果可以将静态文件存储在内存中，效果会更佳，使用<code>Swoole</code>应该可以实现。</p><h3 id="更新缓存"><a href="#更新缓存" class="headerlink" title="更新缓存"></a>更新缓存</h3><p>刷新指定<code>Redis</code>键值即可<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache::put($key, date(<span class="string">'YmdHis'</span>), $expires);</span><br></pre></td></tr></table></figure></p><h3 id="思考？"><a href="#思考？" class="headerlink" title="思考？"></a>思考？</h3><p>这种思路，只适合小产品，可能还会存在其他的问题，所以需要慎用。不过，敢于尝试才会懂得！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;页面静态缓存&quot;&gt;&lt;a href=&quot;#页面静态缓存&quot; class=&quot;headerlink&quot; title=&quot;页面静态缓存&quot;&gt;&lt;/a&gt;页面静态缓存&lt;/h2&gt;&lt;p&gt;页面缓存就是在用户访问页面时，直接返回静态文件，减少了每次请求的业务处理和模板渲染，从而提高网站的&lt;code
      
    
    </summary>
    
      <category term="PHP" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/PHP/"/>
    
      <category term="Composer" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/Composer/"/>
    
      <category term="Laravel" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/Laravel/"/>
    
      <category term="Cache" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>Vue + Webpack 学习笔记</title>
    <link href="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/2018-11-13/vue-webpack-learn-note/"/>
    <id>https://xuehui.我爱你/2018-11-13/vue-webpack-learn-note/</id>
    <published>2018-11-13T02:01:00.000Z</published>
    <updated>2018-11-13T02:22:32.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue-安装"><a href="#Vue-安装" class="headerlink" title="Vue 安装"></a>Vue 安装</h2><ul><li>CDN</li></ul><p>这个一个很好的开始，直接在页面引入 script 标签，就可以开启 Vue 的世界！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然如果你担心直接引入 script 标签会有一天失效，可以下载文件保存到自己的服务器中，然后引用自己的服务链接。我开发工作中也经常这么干，缺点就是如果访问流量较大，还是需要加 CDN 进行缓冲。</p><ul><li>Webpack</li></ul><p>非常有意思的开发方式，前端现在最火的打包和构建工具，它的强大而我还只能远望，使用 Webpack 构建，Vue 官方文档也提供了支持：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'vue$'</span>: <span class="string">'vue/dist/vue.esm.js'</span> <span class="comment">// 用 webpack 1 时需用 'vue/dist/vue.common.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个很重要，否则 <code>import Vue form &#39;vue&#39;;</code> 永远是一片空白的（ #app ）渲染结果！我刚开始使用的时候，就怎么也想不明白，只能说看文档很重要。</p><h2 id="Webpack-配置"><a href="#Webpack-配置" class="headerlink" title="Webpack 配置"></a>Webpack 配置</h2><p>最简单的一份配置文件，单一入口 main.js 文件，默认来自 src 目录 ；构建压缩输出 bundle.js 文件，默认输出到 dist 目录</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line">    entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">'bundle.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            <span class="string">'vue$'</span>: <span class="string">'vue/dist/vue.esm.js'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><p>配置中 mode 来自 Webpack4 的特性！<br>源文件 main.js 引入 vue 并构建 vue 对象，定义数据 message 字符串，还定义 method reverseMessage 将字符串进行翻转操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      message: <span class="string">'Hello Vue.js!'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      reverseMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>入口页面 index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue - Learn<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h4</span>&gt;</span> Vue - Learn <span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app-5"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"reverseMessage"</span>&gt;</span>逆转消息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../dist/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>依赖包 package.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"vue-demo"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"webpack.config.js"</span>,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"vue"</span>: <span class="string">"^2.5.10"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.25.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.1.2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 首选安装依赖扩展，建议使用国内源</span><br><span class="line">npm install </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 构建 bundle.js</span><br><span class="line">webpack</span><br></pre></td></tr></table></figure><p>输入 webpack 时，你可能会发现命令找不到；是的，你全局没有这个命令，所以你可以选择选择安装方式 npm install g webpack，或者也可以使用 ./node_modules/webpack/bin/webpack 相对路径执行命令。还有一种是推荐的方法，在 package.json 中添加 scripts</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "build": "webpack"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，就可以执行使用 npm run build 命令，它代表的命令就是 ./node_modules/webpack/bin/webpack</p><p>done 运行结果：</p><p><img src="/images/demo.png" alt="vue-demo"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vue-安装&quot;&gt;&lt;a href=&quot;#Vue-安装&quot; class=&quot;headerlink&quot; title=&quot;Vue 安装&quot;&gt;&lt;/a&gt;Vue 安装&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CDN&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个一个很好的开始，直接在页面引入 script 标签，就可
      
    
    </summary>
    
      <category term="Vue" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/Vue/"/>
    
      <category term="Webpack" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Autoload类的自动加载</title>
    <link href="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/2018-11-07/autoload-class-for-php/"/>
    <id>https://xuehui.我爱你/2018-11-07/autoload-class-for-php/</id>
    <published>2018-11-07T06:00:00.000Z</published>
    <updated>2018-11-08T01:09:44.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类的自动加载"><a href="#类的自动加载" class="headerlink" title="类的自动加载"></a>类的自动加载</h2><p>PHP面向对象程序设计过程中，必然需要定义很多类，也就是非常多的.PHP文件。在PHP5之前，我们如果在一个类中引用另一个类，需要在这个类的文件头部加上<code>require</code>或者<code>include</code>。但是，如果我们的系统非常复杂，涉及极多的类时，这样的操作显得非常繁琐。</p><p>在PHP5中，已经不再需要这样了。 <code>spl_autoload_register()</code> 函数可以注册任意数量的自动加载器，当使用尚未被定义的类和接口时自动去加载。通过注册自动加载器，脚本引擎在PHP出错失败前有了最后一个机会加载所需的类。</p><hr><p>尝试分别从 <code>MyClass1.php</code> 和 <code>MyClass2.php</code> 文件中加载 <code>MyClass1</code> 和 <code>MyClass2</code> 类</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">spl_autoload_register(<span class="function"><span class="keyword">function</span> <span class="params">($class_name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">require_once</span> $class_name . <span class="string">'.php'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$obj  = <span class="keyword">new</span> MyClass1();</span><br><span class="line">$obj2 = <span class="keyword">new</span> MyClass2();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>将一个异常抛给不存在的自定义异常处理函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">spl_autoload_register(<span class="function"><span class="keyword">function</span> <span class="params">($name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Want to load $name.\n"</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MissingException(<span class="string">"Unable to load $name."</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $obj = <span class="keyword">new</span> NonLoadableClass();</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;getMessage(), <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Composer-自动加载"><a href="#Composer-自动加载" class="headerlink" title="Composer 自动加载"></a>Composer 自动加载</h3><p><code>composer</code> 提供了四种自动加载类型</p><ul><li>classmap</li><li>psr-0</li><li>psr-4</li><li>files</li></ul><p>这几种自动加载平常的框架都用到，通常来看，项目代码用<code>psr-4</code>自动加载， 如<code>Laravel</code>框架的函数库<code>helper</code>用<code>files</code>自动加载，<code>development</code>相关用<code>classmap</code>自动加载，而<code>psr-0</code>已经弃用，有事兼容古老的代码还会用到。</p><h4 id="classmap"><a href="#classmap" class="headerlink" title="classmap"></a>classmap</h4><p><code>composer</code>会扫描指定目录下以<code>.php</code> 或<code>.inc</code>结尾的文件中的<code>class</code>，生成<code>class</code>到指定<code>file-path</code>的映射(Key-Value)，并加入新生成的<code>vendor/composer/autoload_classmap.php</code>文件中</p><p>例如：</p><p>配置扫描路径<code>src</code><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"autoload"</span>: &#123;</span><br><span class="line">    <span class="attr">"classmap"</span>: [<span class="string">"src/"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其生成结果如下<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">'BaseController'</span> =&gt; $baseDir . <span class="string">'/src/BaseController.php'</span></span><br><span class="line">);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="psr-4"><a href="#psr-4" class="headerlink" title="psr-4"></a>psr-4</h4><p>在<code>composer.json</code>里是这样进行配置的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"autoload"</span>: &#123;</span><br><span class="line">    <span class="attr">"psr-4"</span>: &#123;</span><br><span class="line">      <span class="attr">"Foo\\"</span>: <span class="string">"src/"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>composer install</code>更新自动加载。照<code>PSR-4</code>的规则，当在<code>index.php</code>中试图<code>new Foo\Bar\Baz</code>这个<code>class</code>时，<code>composer</code>会自动去寻找 <code>src/Bar/Baz.php&quot;</code> 这个文件，如果它存在则进行加载。</p><h4 id="files"><a href="#files" class="headerlink" title="files"></a>files</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"autoload"</span>: &#123;</span><br><span class="line">    <span class="attr">"files"</span>: [<span class="string">"src/MyLibrary/functions.php"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>composer install</code>更新自动加载。<code>Files</code>方式，就是手动指定供直接加载的文件。比如说我们有一系列全局的<code>helper functions</code>，可以放到一个<code>helper</code>文件里然后直接进行加载，也就是说，当你用<code>require &#39;vendor/autoload.php&#39;</code>加载自动加载类时自动将<code>files</code>里的文件加载进来了，你直接使用就行了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;类的自动加载&quot;&gt;&lt;a href=&quot;#类的自动加载&quot; class=&quot;headerlink&quot; title=&quot;类的自动加载&quot;&gt;&lt;/a&gt;类的自动加载&lt;/h2&gt;&lt;p&gt;PHP面向对象程序设计过程中，必然需要定义很多类，也就是非常多的.PHP文件。在PHP5之前，我们如果在一个
      
    
    </summary>
    
      <category term="PHP" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/PHP/"/>
    
      <category term="Composer" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/Composer/"/>
    
  </entry>
  
  <entry>
    <title>Git-工具 存储凭证</title>
    <link href="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/2018-11-05/gittool-storage-credentials/"/>
    <id>https://xuehui.我爱你/2018-11-05/gittool-storage-credentials/</id>
    <published>2018-11-05T06:00:00.000Z</published>
    <updated>2019-01-10T08:06:01.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git存储凭证管理"><a href="#Git存储凭证管理" class="headerlink" title="Git存储凭证管理"></a>Git存储凭证管理</h2><p>如果你使用的是 SSH 方式连接远端，并且设置了一个没有口令的密钥，这样就可以在不输入用户名和密码的情况下安全地传输数据。 然而，这对 HTTP 协议来说是不可能的，每一个连接都是需要用户名和密码的。 这在使用双重认证的情况下会更麻烦，因为你需要输入一个随机生成并且毫无规律的 token 作为密码。</p><hr><p>幸运的是，Git 拥有一个凭证系统来处理这个事情。 下面有一些 Git 的选项：</p><ul><li>默认所有都不缓存。 每一次连接都会询问你的用户名和密码。</li><li>“cache” 模式会将凭证存放在内存中一段时间。 密码永远不会被存储在磁盘中，并且在15分钟后从内存中清除。</li><li>“store” 模式会将凭证用明文的形式存放在磁盘中，并且永不过期。 这意味着除非你修改了你在 Git 服务器上的密码，否则你永远不需要再次输入你的凭证信息。 这种方式的缺点是你的密码是用明文的方式存放在你的 home 目录下。</li><li>如果你使用的是 Mac，Git 还有一种 “osxkeychain” 模式，它会将凭证缓存到你系统用户的钥匙串中。 这种方式将凭证存放在磁盘中，并且永不过期，但是是被加密的，这种加密方式与存放 HTTPS 凭证以及 Safari 的自动填写是相同的。</li><li>如果你使用的是 Windows，你可以安装一个叫做 “winstore” 的辅助工具。 这和上面说的 “osxkeychain” 十分类似，但是是使用 Windows Credential Store 来控制敏感信息。</li></ul><blockquote><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%87%AD%E8%AF%81%E5%AD%98%E5%82%A8" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%87%AD%E8%AF%81%E5%AD%98%E5%82%A8</a></p></blockquote><h2 id="Composer-使用Git私有库，composer-install-404-Not-Found-异常问题"><a href="#Composer-使用Git私有库，composer-install-404-Not-Found-异常问题" class="headerlink" title="Composer 使用Git私有库，composer install 404 Not Found 异常问题"></a>Composer 使用Git私有库，<code>composer install</code> 404 Not Found 异常问题</h2><p><strong>我们团队遇到的问题</strong></p><ul><li>团队有一开发人员<code>A</code>使用<code>mac</code>环境开发（Git存储凭证<code>osxkeychain</code>模式会永久缓存凭证）</li><li>我们现在有两个主项目<code>P1</code>和<code>P2</code>和一个私有扩展库<code>F3</code></li><li><code>A</code>开发者拥有<code>P1</code>和<code>P2</code>访问权限，并通过<code>HTTP</code>协议<code>Clone</code>项目<code>P1</code>的源代码（经过了这一步操作，会存储凭证信息）</li><li><code>P2</code>项目使用PHP语言并通过<code>Composer</code>工具管理依赖，其中包含<code>F3</code>扩展包</li></ul><p><code>Composer.json</code>:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"git"</span>,</span><br><span class="line">  <span class="attr">"url"</span>: <span class="string">"http://domain/F3.git"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Auth.json</code>:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"http-basic"</span>: &#123;</span><br><span class="line">    <span class="attr">"your-domain"</span>: &#123;</span><br><span class="line">      <span class="attr">"username"</span>: <span class="string">"your-token"</span>,</span><br><span class="line">      <span class="attr">"password"</span>: <span class="string">"your-password"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>当<code>A</code>用户克隆<code>P2</code>项目后使用<code>composer install</code>安装依赖会出现异<code>404 Not Found F3</code>，无法成功安装<code>F3</code>扩展</strong></p><p>我当时很疑惑？为什么不使用<code>Auth.json</code>进行验证？实际使用了缓存中凭证，可以说是Composer没有考虑到的极端情况。</p><p><strong>解决办法?</strong></p><p>composer install 出现无法拉取私有扩展包时</p><h3 id="1-清除Git存储凭证"><a href="#1-清除Git存储凭证" class="headerlink" title="1.清除Git存储凭证"></a>1.清除Git存储凭证</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 全部 unset 一遍呗</span><br><span class="line"><span class="meta">$</span> git config --local --unset credential.helper</span><br><span class="line"><span class="meta">$</span> git config --global --unset credential.helper</span><br><span class="line"><span class="meta">$</span> sudo git config --system --unset credential.helper</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 这三个命令都没有显示任何东西了</span><br><span class="line"><span class="meta">$</span> git config --local credential.helper</span><br><span class="line"><span class="meta">$</span> git config --global credential.helper</span><br><span class="line"><span class="meta">$</span> git config --system credential.helper</span><br></pre></td></tr></table></figure><p>hmm 如果还不生效 ？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查看是否仍存在 osxkeychain</span><br><span class="line"><span class="meta">$</span> git config -l</span><br><span class="line">credential.helper=osxkeychain</span><br><span class="line"><span class="meta">#</span> 获取真正的路径，找到对应文件手工删掉即可</span><br><span class="line"><span class="meta">$</span> git config --show-origin --get credential.helper</span><br><span class="line">file:/Applications/Xcode.app/Contents/Developer/usr/share/git-core/gitconfig    osxkeychain</span><br></pre></td></tr></table></figure><h3 id="2-使用带用户名和密码的-git"><a href="#2-使用带用户名和密码的-git" class="headerlink" title="2.使用带用户名和密码的.git"></a>2.使用带用户名和密码的.git</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://yourusername:yourpassword@gitlab.domain.com/project.git</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git存储凭证管理&quot;&gt;&lt;a href=&quot;#Git存储凭证管理&quot; class=&quot;headerlink&quot; title=&quot;Git存储凭证管理&quot;&gt;&lt;/a&gt;Git存储凭证管理&lt;/h2&gt;&lt;p&gt;如果你使用的是 SSH 方式连接远端，并且设置了一个没有口令的密钥，这样就可以在不输
      
    
    </summary>
    
      <category term="Git" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/categories/Git/"/>
    
    
      <category term="Git" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>细细品味 Laravel-Schedule 计划任务的原理</title>
    <link href="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/2018-10-30/savour-the-principles-of-laravelschedule-planning-task/"/>
    <id>https://xuehui.我爱你/2018-10-30/savour-the-principles-of-laravelschedule-planning-task/</id>
    <published>2018-10-30T06:00:00.000Z</published>
    <updated>2018-11-06T13:10:37.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Laravel-Schedule-原理剖析"><a href="#Laravel-Schedule-原理剖析" class="headerlink" title="Laravel-Schedule 原理剖析"></a>Laravel-Schedule 原理剖析</h2><p>介绍原理之前，先自省几句，很长一段时间没有码字啦，那种工作停不下来的习惯得改一改。再忙都应该给自己留出一点空闲的时间，用来总结和提升技能。</p><p>到此为止</p><hr><h3 id="事情起因："><a href="#事情起因：" class="headerlink" title="事情起因："></a>事情起因：</h3><p>昨天，在工作过程中和同事讨论到<code>Laravel-Schedule</code>任务计划的问题。本来，对<code>Schedule</code>没有深入探索，并不理解任务的注册和执行过程，基于这个问题，我快速浏览了一遍这个模块的源代码。<br>并结合自己的理解来描述<code>Laravel-Schedule</code>的基本执行原理，可能有很多不正确的地方，勿喷，如果你有不同的看法，可以在下方留言并一起探索，感谢！</p><h3 id="文章概述"><a href="#文章概述" class="headerlink" title="文章概述"></a>文章概述</h3><p><code>LS</code>计划任务，名称太长，本文使用<code>LS</code>代替<code>Laravel-Schedule</code>长命名。</p><p><code>LS</code>流程分为两个步骤：</p><ul><li>第一步，根据配置的Command命令、Cron表达式进行注册事件；</li><li>第二步，操作系统配置每分钟触发<code>LS</code>，由<code>LS</code>自主完成事件<code>是否符合执行时间过滤</code>，<code>重复性检查</code>，并可选<code>Background</code>或者<code>Foreground</code>进行执行任务。</li></ul><h3 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h3><p>在命令行应用程序入口文件<code>artisan</code>首先引入<code>bootstrap/app.php</code><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$app-&gt;singleton(</span><br><span class="line">    Illuminate\Contracts\Console\Kernel::class,</span><br><span class="line">    App\Console\Kernel::class</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>向容器中注册<code>Laravel-Kernel</code>，并使用<code>make</code>构建实例<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$kernel = $app-&gt;make(Illuminate\Contracts\Console\Kernel::class);</span><br></pre></td></tr></table></figure></p><p><code>App\Console\Kernel</code> 继承于 <code>Illuminate\Foundation\Console\Kernel</code></p><p>所以在实例过程中会调用<code>Illuminate\Foundation\Console\Kernel</code>构造方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(Application $app, Dispatcher $events)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! defined(<span class="string">'ARTISAN_BINARY'</span>)) &#123;</span><br><span class="line">        define(<span class="string">'ARTISAN_BINARY'</span>, <span class="string">'artisan'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;app = $app;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;events = $events;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;app-&gt;booted(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;defineConsoleSchedule();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又完成了一次事件注册，在应用启动<code>booted</code>完成后回调 <code>$this-&gt;defineConsoleSchedule()</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">defineConsoleSchedule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;app-&gt;singleton(Schedule::class, <span class="function"><span class="keyword">function</span> <span class="params">($app)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Schedule;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    $schedule = <span class="keyword">$this</span>-&gt;app-&gt;make(Schedule::class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;schedule($schedule);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点在于<code>defineConsoleSchedule</code>这个方法，容器中注册并实例化<code>Schedule</code>对象，并使用址传递对<code>Schedule</code>实例进行操作，<strong>这里的操作就是计划任务的事件注册</strong>。</p><p><code>Illuminate\Foundation\Console\Kernel</code> 中的<code>schedule</code>方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Define the application's command schedule.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>  \Illuminate\Console\Scheduling\Schedule  $schedule</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">schedule</span><span class="params">(Schedule $schedule)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们不需要在这里修改任何代码。上面，我们说过<code>Laravel-Kernel</code>对象的实例类是<code>App\Console\Kernel</code>，他继承了<code>Illuminate\Foundation\Console\Kernel</code>类。<br><br>所以我们在官方文档中也可以清楚看到，计划任务的配置是在<code>App\Console\Kernel</code>中的<code>schedule</code>方法中定义的，例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Define the application's command schedule.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>  \Illuminate\Console\Scheduling\Schedule $schedule</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">schedule</span><span class="params">(Schedule $schedule)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $schedule-&gt;command(<span class="string">'inspire'</span>)-&gt;hourly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看<strong>官方文档</strong>的解读：</p><h4 id="Closure-定义调度"><a href="#Closure-定义调度" class="headerlink" title="Closure 定义调度"></a>Closure 定义调度</h4><p>使用<code>Closure</code>定义调度。例如，每天使用DB构造器方式来清空数据库一个表</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$schedule-&gt;call(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    DB::table(<span class="string">'recent_users'</span>)-&gt;delete();</span><br><span class="line">&#125;)-&gt;daily();</span><br></pre></td></tr></table></figure><h4 id="Artisan-命令调度"><a href="#Artisan-命令调度" class="headerlink" title="Artisan 命令调度"></a>Artisan 命令调度</h4><p>除了计划 Closure 调用，你还能调度 Artisan 命令 和操作系统命令。举个例子，你可以给 command 方法传递命令名称或者类名称来调度一个 Artisan 命令：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$schedule-&gt;command(<span class="string">'emails:send --force'</span>)-&gt;daily();</span><br></pre></td></tr></table></figure><h4 id="队列任务调度"><a href="#队列任务调度" class="headerlink" title="队列任务调度"></a>队列任务调度</h4><p><code>job</code>方法可以用来调度 队列任务。这个方法提供了一种快捷方式来调度任务，无需使用<code>call</code>方法手动创建闭包来调度任务：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$schedule-&gt;job(<span class="keyword">new</span> Heartbeat)-&gt;everyFiveMinutes();</span><br></pre></td></tr></table></figure><h4 id="Shell-命令调度"><a href="#Shell-命令调度" class="headerlink" title="Shell 命令调度"></a>Shell 命令调度</h4><p>exec 方法可用于向操作系统发出命令：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$schedule-&gt;exec(<span class="string">'node /home/forge/script.js'</span>)-&gt;daily();</span><br></pre></td></tr></table></figure></p><p><code>LS</code> 提供很多提高我们开发效率的执行频率方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>-&gt;cron(‘<em> </em> <em> </em> <em> </em>‘);</td><td>在自定义的 Cron 时间表上执行该任务</td></tr><tr><td>-&gt;everyMinute();</td><td>每分钟执行一次任务</td></tr><tr><td>-&gt;everyFiveMinutes();</td><td>每五分钟执行一次任务</td></tr><tr><td>-&gt;everyTenMinutes();</td><td>每十分钟执行一次任务</td></tr><tr><td>-&gt;everyFifteenMinutes();</td><td>每十五分钟执行一次任务</td></tr><tr><td>-&gt;everyThirtyMinutes();</td><td>每半小时执行一次任务</td></tr><tr><td>-&gt;hourly();</td><td>每小时执行一次任务</td></tr><tr><td>-&gt;hourlyAt(17);</td><td>每小时的第 17 分钟执行一次任务</td></tr><tr><td>-&gt;daily();</td><td>每天午夜执行一次任务</td></tr><tr><td>-&gt;dailyAt(‘13:00’);</td><td>每天的 13:00 执行一次任务</td></tr><tr><td>-&gt;twiceDaily(1, 13);</td><td>每天的 1:00 和 13:00 分别执行一次任务</td></tr><tr><td>-&gt;weekly();</td><td>每周执行一次任务</td></tr><tr><td>-&gt;monthly();</td><td>每月执行一次任务</td></tr><tr><td>-&gt;monthlyOn(4, ‘15:00’);</td><td>在每个月的第四天的 15:00 执行一次任务</td></tr><tr><td>-&gt;quarterly();</td><td>每季度执行一次任务</td></tr><tr><td>-&gt;yearly();</td><td>每年执行一次任务</td></tr><tr><td>-&gt;timezone(‘America/New_York’);</td><td>设置时区</td></tr></tbody></table><p>了解<code>LS</code>给我们提供的多种任务定义和执行频率设置的方式后，我们回来思考其实现的原理是怎么样的？</p><p><strong><code>schedule</code>方法里的每一句任务的定义，就是构造一个事件对象，并将这个事件对象放到数组里</strong></p><p><code>Illuminate\Console\Scheduling\Schedule.php</code> command方法的核心实现代码如下:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">$this</span>-&gt;events[] = $event = <span class="keyword">new</span> Event(<span class="keyword">$this</span>-&gt;mutex, $command);</span><br></pre></td></tr></table></figure></p><p><code>mutex</code> 这个变量用来控制事件当前时间执行的不可重复性，在这里先不细究。</p><p><strong><code>schedule</code>方法里的每一句调度频率设置，就是表达式的构建</strong></p><p>这个表达式 <code>expression</code> 就是与我们常用<code>crontab</code>表达式是同样的类型，<code>everyTenMinutes()</code> 每十分钟执行一次，其实对应的表达式就是<code>*/10 * * * * *</code>，具体<code>LS</code> 实现代码如下，应该不难看懂。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> $expression = <span class="string">'* * * * * *'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">everyTenMinutes</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;spliceIntoPosition(<span class="number">1</span>, <span class="string">'*/10'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">spliceIntoPosition</span><span class="params">($position, $value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $segments = explode(<span class="string">' '</span>, <span class="keyword">$this</span>-&gt;expression);</span><br><span class="line">    $segments[$position - <span class="number">1</span>] = $value;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;cron(implode(<span class="string">' '</span>, $segments));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个很重要，因为事件的过滤中，需要匹配执行时间是否等于当前时间。</p><h3 id="运行事件"><a href="#运行事件" class="headerlink" title="运行事件"></a>运行事件</h3><p>启动调度器，使用调度器时，只需将以下<code>Cron</code>项目添加到服务器:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * php /path-to-your-project/artisan schedule:run &gt;&gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>上面这个<code>Cron</code>会每分钟调用一次<code>LS</code>命令调度器。执行<code>schedule:run</code>命令时， <code>LS</code>会根据你的调度运行预定任务。</p><p>让我们带着疑问继续理解<code>LS</code>运行事件原理。</p><h4 id="schedule-run-是什么？"><a href="#schedule-run-是什么？" class="headerlink" title="schedule:run 是什么？"></a>schedule:run 是什么？</h4><p>我们看 <code>Illuminate\Console\Scheduling\ScheduleRunCommand</code> 代码是怎么写的？和普通自定义<code>Artisan</code>命令一样，继承 <code>Command</code> 基类。然后具体任务内容在<code>handle</code>方法里实现。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScheduleRunCommand</span> <span class="keyword">extends</span> <span class="title">Command</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;schedule-&gt;dueEvents(<span class="keyword">$this</span>-&gt;laravel) <span class="keyword">as</span> $event) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            $event-&gt;run(<span class="keyword">$this</span>-&gt;laravel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dueEvents</code> 完成过滤动作 <code>collect($this-&gt;events)-&gt;filter-&gt;isDue($app)</code> 使用 <code>isDue</code> 方法进行过滤。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isDue</span><span class="params">($app)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! <span class="keyword">$this</span>-&gt;runsInMaintenanceMode() &amp;&amp; $app-&gt;isDownForMaintenance()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;expressionPasses() &amp;&amp;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;runsInEnvironment($app-&gt;environment());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">expressionPasses</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $date = Carbon::now();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;timezone) &#123;</span><br><span class="line">        $date-&gt;setTimezone(<span class="keyword">$this</span>-&gt;timezone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CronExpression::factory(<span class="keyword">$this</span>-&gt;expression)-&gt;isDue($date-&gt;toDateTimeString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实原理很简单，方法<code>expressionPasses</code>通过<code>Carbon</code>第三方扩展包获取当前时间，并与Event实例的<code>Expression</code>进行匹对。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">$this</span>-&gt;getNextRunDate($currentDate, <span class="number">0</span>, <span class="keyword">true</span>)-&gt;getTimestamp() == $currentTime</span><br></pre></td></tr></table></figure><p>如果返回<code>True</code>，那就表示<code>Event</code>需要执行。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$event-&gt;run(<span class="keyword">$this</span>-&gt;laravel);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">(Container $container)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;withoutOverlapping &amp;&amp;</span><br><span class="line">        ! <span class="keyword">$this</span>-&gt;mutex-&gt;create(<span class="keyword">$this</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;runInBackground</span><br><span class="line">                ? <span class="keyword">$this</span>-&gt;runCommandInBackground($container)</span><br><span class="line">                : <span class="keyword">$this</span>-&gt;runCommandInForeground($container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>withoutOverlapping</code> 和 <code>mutex</code> 就是在这里控制任务重复执行。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> Process(</span><br><span class="line">    <span class="keyword">$this</span>-&gt;buildCommand(), base_path(), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span></span><br><span class="line">))-&gt;run();</span><br></pre></td></tr></table></figure><p>最后，由执行器执行命令任务…done</p><hr><h3 id="几点疑问？"><a href="#几点疑问？" class="headerlink" title="几点疑问？"></a>几点疑问？</h3><p><strong>1.假设每个五分钟执行，比如08:52定义命令调度<code>Command</code>到<code>Schedule</code>，会在08:57时刻执行？</strong></p><p>不会，只会在08:55时刻执行，也就是满足时钟的固定周期。</p><p><strong>2.任务调度的两种执行方式<code>runCommandInBackground</code> 与 <code>runCommandInForeground</code> 有什么区别？</strong></p><p><code>runCommandInBackground</code> 代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">runCommandInBackground</span><span class="params">(Container $container)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;callBeforeCallbacks($container);</span><br><span class="line"></span><br><span class="line">    (<span class="keyword">new</span> Process(</span><br><span class="line">        <span class="keyword">$this</span>-&gt;buildCommand(), base_path(), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span></span><br><span class="line">    ))-&gt;run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runCommandInForeground</code> 代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">runCommandInForeground</span><span class="params">(Container $container)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;callBeforeCallbacks($container);</span><br><span class="line"></span><br><span class="line">    (<span class="keyword">new</span> Process(</span><br><span class="line">        <span class="keyword">$this</span>-&gt;buildCommand(), base_path(), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span></span><br><span class="line">    ))-&gt;run();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;callAfterCallbacks($container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>差别在于 <code>$this-&gt;callAfterCallbacks($container)</code> ，是否等待当前任务执行完成，如果选择 <code>runCommandInBackground</code> 方式运行，任务命令直接传递给操作系统进行执行，然后直接返回，等待操作系统执行完成任务后，会执行另一条命令 <code>schedule:finish</code> 通过事件ID()进行异步响应对应的任务事件。</p><p><strong>3.Closure 定义调度，和命令其他方式定义调度是不相同的，详细可以查看<code>CallBackEvent-&gt;run()</code> 同步方式执行</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Laravel-Schedule-原理剖析&quot;&gt;&lt;a href=&quot;#Laravel-Schedule-原理剖析&quot; class=&quot;headerlink&quot; title=&quot;Laravel-Schedule 原理剖析&quot;&gt;&lt;/a&gt;Laravel-Schedule 原理剖析&lt;/
      
    
    </summary>
    
      <category term="Laravel" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/categories/Laravel/"/>
    
    
      <category term="Laravel" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/Laravel/"/>
    
      <category term="Schedule" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/Schedule/"/>
    
  </entry>
  
  <entry>
    <title>网站SEO优化方案</title>
    <link href="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/2018-09-06/website-seo-optimization-solution/"/>
    <id>https://xuehui.我爱你/2018-09-06/website-seo-optimization-solution/</id>
    <published>2018-09-06T07:12:00.000Z</published>
    <updated>2018-11-06T13:11:00.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网站SEO优化方案"><a href="#网站SEO优化方案" class="headerlink" title="网站SEO优化方案"></a>网站SEO优化方案</h2><h3 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h3><ul><li><p>1、熟悉业务、了解用户行为、研究关键词并建立关键词库；</p></li><li><p>2、熟悉自身及竞争对手网站构架、内容组织形式并针对性部署GA代码；</p></li><li><p>3、根据重点关键词对照网站页面以确定Meta修改或频道新增方案；</p></li><li><p>4、分析服务器日志了解整站搜索引擎资源配比及问题，执行页面修改、Robots修改、Sitemap修改、新增页面及调整服务器等方案；</p></li><li><p>5、审查页面元素、内容布局、加载及代码等并执行相应方案；</p></li><li><p>6、结合服务器日志及用户体验构建站内链接推荐系统并执行相应方案；</p></li><li><p>7、确定域名、URL等是否有必要修改并执行相应方案；</p></li><li><p>8、参与搜索引擎新闻源、开放平台等合作；</p></li><li><p>9、定期给编辑人员提供关键词以供内容运营；</p></li><li><p>10、根据自身及竞争对手情况，交换友情链接、制造外链等；</p></li><li><p>11、网站页面细化分类并对比分析爬取、收录、流量、排名等数据并针对性执行相应方案；</p></li><li><p>12、通过百科、知道、文库、论坛等吸引品牌词或引荐流量；</p></li><li><p>13、分析用户的网站行为，并指导产品经理进行改进；</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网站SEO优化方案&quot;&gt;&lt;a href=&quot;#网站SEO优化方案&quot; class=&quot;headerlink&quot; title=&quot;网站SEO优化方案&quot;&gt;&lt;/a&gt;网站SEO优化方案&lt;/h2&gt;&lt;h3 id=&quot;优化步骤&quot;&gt;&lt;a href=&quot;#优化步骤&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="SEO" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/categories/SEO/"/>
    
    
      <category term="SEO" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>大数据比赛</title>
    <link href="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/2018-09-04/big-data-contest/"/>
    <id>https://xuehui.我爱你/2018-09-04/big-data-contest/</id>
    <published>2018-09-04T07:12:00.000Z</published>
    <updated>2018-11-06T13:07:17.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大数据比赛"><a href="#大数据比赛" class="headerlink" title="大数据比赛"></a>大数据比赛</h2><h3 id="比赛日程"><a href="#比赛日程" class="headerlink" title="比赛日程"></a>比赛日程</h3><ul><li>第一天，参与大数据应用的培训课程，了解与熟悉搭建大数据平台所使用的工具；</li><li>第二天，大数据工具使用实践，掌握操作平台的基本命令与技巧；</li><li>第三天，比赛正式开始，将采集数据导入大数据平台，并使用Hive等工具对数据进行探索；</li><li>第四天，假设分析模型，并对模型进行验证和可行性分析；</li><li>第五天，数据过滤与特征项提取，并消除数据噪音，得到合适模型输入的数据集；</li><li>第六天，模型训练，并调优参数，拟合数学模型得出应用模型，并对应用模型进行R平方与F验证；</li><li>第七天，内容梳理，准备汇报PPT与演示DEMO程序；</li><li>第八天，成果汇报与应用展示，听取评委意见，参加颁奖与比赛结束合影；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;大数据比赛&quot;&gt;&lt;a href=&quot;#大数据比赛&quot; class=&quot;headerlink&quot; title=&quot;大数据比赛&quot;&gt;&lt;/a&gt;大数据比赛&lt;/h2&gt;&lt;h3 id=&quot;比赛日程&quot;&gt;&lt;a href=&quot;#比赛日程&quot; class=&quot;headerlink&quot; title=&quot;比赛日程&quot;
      
    
    </summary>
    
      <category term="数据挖掘" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="大数据" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="数据挖掘" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>聊聊跨域问题</title>
    <link href="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/2018-08-23/talking-about-crossdomain-issues/"/>
    <id>https://xuehui.我爱你/2018-08-23/talking-about-crossdomain-issues/</id>
    <published>2018-08-23T07:12:00.000Z</published>
    <updated>2018-11-07T00:59:30.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>跨域，就是Web浏览器的同源政策的约束</p><p>在文章 《Web浏览器同源政策及其规避方法》 已经详细讲解 </p><p><a href="https://www.helingfeng.com/2018-06-12/web-browser-homology-policy-and-its-avoidance-method/">https://www.helingfeng.com/2018-06-12/web-browser-homology-policy-and-its-avoidance-method/</a></p><h2 id="问题1：跨域时，需要携带-Cookies"><a href="#问题1：跨域时，需要携带-Cookies" class="headerlink" title="问题1：跨域时，需要携带 Cookies"></a>问题1：跨域时，需要携带 <code>Cookies</code></h2><p>解决办法：对于<code>ajax</code>异步请求，需要添加参数 <code>withCredentials: true</code> </p><p>JQuery 实例： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>.ajax(&#123;</span><br><span class="line">   url: a_cross_domain_url,</span><br><span class="line">   // 将XHR对象的withCredentials设为true</span><br><span class="line">   xhrFields: &#123;</span><br><span class="line">      withCredentials: true</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意：使用<code>withCredentials=true</code> 时，allow-origin 需要指定<code>host</code>,而不能使用<code>*</code>通配</p><p>例如：<code>www.demo.com</code> 进行跨域请求<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// add_header Access-Control-Allow-Origin *; //错误写法</span><br><span class="line">add_header Access-Control-Allow-Origin www.demo.com;  // 正确写法</span><br><span class="line">add_header Access-Control-Allow-Credentials true always;</span><br><span class="line">add_header Access-Control-Allow-Headers Content-Type,Authorization,Accept,X-Requested-With,X-CSRF-TOKEN,withCredentials always;</span><br><span class="line">add_header Access-Control-Allow-Methods GET,POST,OPTIONS,DELETE,PUT always;</span><br></pre></td></tr></table></figure></p><h2 id="问题2：跨域时，后台无法判断-is-ajax"><a href="#问题2：跨域时，后台无法判断-is-ajax" class="headerlink" title="问题2：跨域时，后台无法判断 is_ajax"></a>问题2：跨域时，后台无法判断 <code>is_ajax</code></h2><p>通常情况下，后端通过头部是否存在<code>&#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;</code>来断定异步请求</p><p>jquery ajax 跨域时，不携带此头部描述。</p><p>解决办法：</p><h3 id="1-提交时，带上X-Requested-With头部"><a href="#1-提交时，带上X-Requested-With头部" class="headerlink" title="1. 提交时，带上X-Requested-With头部"></a>1. 提交时，带上<code>X-Requested-With</code>头部</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line"><span class="code">    url: "http://your-url...",</span></span><br><span class="line"><span class="code">    headers: &#123;'X-Requested-With': 'XMLHttpRequest'&#125;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-设置crossDomain"><a href="#2-设置crossDomain" class="headerlink" title="2. 设置crossDomain"></a>2. 设置<code>crossDomain</code></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line"><span class="code">    url: "http://your-url...",</span></span><br><span class="line"><span class="code">    crossDomain: false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是跨域&quot;&gt;&lt;a href=&quot;#什么是跨域&quot; class=&quot;headerlink&quot; title=&quot;什么是跨域&quot;&gt;&lt;/a&gt;什么是跨域&lt;/h2&gt;&lt;p&gt;跨域，就是Web浏览器的同源政策的约束&lt;/p&gt;
&lt;p&gt;在文章 《Web浏览器同源政策及其规避方法》 已经详细讲解 &lt;
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>频繁项数据挖掘</title>
    <link href="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/2018-08-06/frequent-item-data-mining/"/>
    <id>https://xuehui.我爱你/2018-08-06/frequent-item-data-mining/</id>
    <published>2018-08-06T08:46:00.000Z</published>
    <updated>2018-11-06T13:11:42.415Z</updated>
    
    <content type="html"><![CDATA[<h3 id="时代的变迁"><a href="#时代的变迁" class="headerlink" title="时代的变迁"></a>时代的变迁</h3><ul><li>曾经我听一个外国人说过这样一句话，翻译过来是这样的意思：<code>程序员</code>就好比<code>建筑工人</code>，如果你不懂数据挖掘与机器学习，那你是一个<code>泥瓦工</code>，反之，你是一位掌握<code>蓝图</code>的工程师。</li></ul><h3 id="数据挖掘-FPGrowth"><a href="#数据挖掘-FPGrowth" class="headerlink" title="数据挖掘 FPGrowth"></a>数据挖掘 FPGrowth</h3><h4 id="涉及算法"><a href="#涉及算法" class="headerlink" title="涉及算法"></a><strong>涉及算法</strong></h4><ul><li><code>Apriori</code> 算法</li><li><code>FPTree</code> 算法</li><li>至于其他算法我也没有研究～</li></ul><h4 id="Apriori算法"><a href="#Apriori算法" class="headerlink" title="Apriori算法"></a><strong>Apriori算法</strong></h4><p>Rakesh Agrawal 和 RamakrishnanSkrikant 提出的一种具有影响力的挖局布尔关联规则的频繁项集的算法。</p><ul><li><strong>算法原理讲解</strong></li></ul><p>假设我们有一家商店，商店有四款产品<code>A</code>,<code>B</code>,<code>C</code>,<code>D</code>;<br>那么所有商品的无序组合方式有<code>15</code>种(2^4-1);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A B C D </span><br><span class="line">AB AC AD BC BD CD </span><br><span class="line">ABC ABD ACD BCD</span><br><span class="line">ABCD</span><br></pre></td></tr></table></figure><p>最<code>暴力</code>的频繁项挖掘算法，可以遍历所有的组合方式，但是组合方式随商品数量增长成<code>指数</code>，所以当商品数量较多时，算法的效率是非常低的。</p><p> 科学家发现一种所谓的Apriori原理，可以帮助我们减少计算量。<br> <code>Apriori原理</code>是说如果某个项集是频繁的，那么它的所有子集也是频繁的。更常用的是它的逆否命题，即如果一个项集是非频繁的，那么它的所有超集也是非频繁的。</p><ul><li><p><strong>基本概念</strong></p><ul><li><code>支持度</code> support=P(AB) 简单来说是指事件A和事件B同时发生的概率</li><li><code>置信度</code> confidence=P(AB)/P(A) 表示所有商品交易中有10%顾客同时买了A商品，并且买B的顾客有50%</li><li><code>K项集</code> K(n)项集满足支持度阈值的必要条件K(n-1)子项集也是频繁项集。</li></ul></li><li><p><strong>算法思路</strong></p></li></ul><p>它使用一种称为逐层搜索的迭代方法，K(n)项集合用于探索K(n+1)集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 首先，确定频繁规则`支持度` support=50%</span><br><span class="line">2. 找出频繁项候选`K1`集，排除支持度阈值不满足的组合，得到频繁项集`L1`</span><br><span class="line">3. 根据`L1`产生候选频繁项集`K2`</span><br><span class="line">4. 重复步骤2和步骤3，直到`Ln`项集合无法再产生候选频繁项</span><br></pre></td></tr></table></figure><ul><li><strong>举个栗子</strong><ul><li>假设支持度min_support=30%</li><li>假设现在有5个顾客的订单记录</li></ul></li></ul><table><thead><tr><th>顾客名称</th><th>订单商品列表</th></tr></thead><tbody><tr><td>张三</td><td>A B C</td></tr><tr><td>李四</td><td>B C D</td></tr><tr><td>王五</td><td>A C</td></tr><tr><td>老六</td><td>B C</td></tr><tr><td>陈七</td><td>E C D</td></tr></tbody></table><hr><p>a. <strong>跟据购买记录的订单列表生产候选频繁项K1。如下表格，</strong></p><table><thead><tr><th>候选频繁项</th><th>支持度数</th></tr></thead><tbody><tr><td>{A}</td><td>2</td></tr><tr><td>{B}</td><td>3</td></tr><tr><td>{C}</td><td>5</td></tr><tr><td>{D}</td><td>2</td></tr><tr><td>{E}</td><td>1</td></tr></tbody></table><hr><p>b. <strong>根据MinSupport=30%得出频繁项集L1</strong></p><table><thead><tr><th>频繁项</th><th>支持度数</th></tr></thead><tbody><tr><td>{A}</td><td>2</td></tr><tr><td>{B}</td><td>3</td></tr><tr><td>{C}</td><td>5</td></tr><tr><td>{D}</td><td>2</td></tr></tbody></table><hr><p>c. <strong>再以L1组合产生候选频繁集K2</strong></p><table><thead><tr><th>候选频繁项</th><th>支持度数</th></tr></thead><tbody><tr><td>{A B}</td><td>1</td></tr><tr><td>{A C}</td><td>2</td></tr><tr><td>{A D}</td><td>0</td></tr><tr><td>{B C}</td><td>3</td></tr><tr><td>{B D}</td><td>1</td></tr><tr><td>{C D}</td><td>2</td></tr></tbody></table><hr><p>e. <strong>根据MinSupport=30%得出频繁项集L2，并输出</strong></p><table><thead><tr><th>频繁项</th><th>支持度数</th></tr></thead><tbody><tr><td>{A C}</td><td>2</td></tr><tr><td>{B C}</td><td>3</td></tr><tr><td>{C D}</td><td>2</td></tr></tbody></table><hr><p>f. <strong>再以L2组合产生候选频繁集K3</strong></p><table><thead><tr><th>候选频繁项</th><th>支持度数</th></tr></thead><tbody><tr><td>{A B C}</td><td>1</td></tr><tr><td>{A B D}</td><td>0</td></tr><tr><td>{A C D}</td><td>0</td></tr><tr><td>{B C D}</td><td>1</td></tr></tbody></table><hr><p>e. <strong>根据MinSupport=30%得出频繁项集L3 = {} 空，算法结束</strong></p><p>最后得到<code>频繁项集</code>为</p><table><thead><tr><th>频繁项</th><th>支持度数</th></tr></thead><tbody><tr><td>{A C}</td><td>2 = 40%顾客同时购买A也购买C</td></tr><tr><td>{B C}</td><td>3 = 60%顾客同时购买B也购买C</td></tr><tr><td>{C D}</td><td>2 = 40%顾客同时购买C也购买D</td></tr></tbody></table><hr><p>到这里已经完成了我们的频繁项挖掘工作，Apriori算法其实还挺简单理解的。<br>一切东西都是从简单开始的，从简到繁，学习也是这样，不然一开始就被概念吓倒，以后还会有精力和兴趣吗？</p><p>说好的附PHP源码呢？</p><p>个人编码能力有限，在此献丑了</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Apriori 算法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created by PhpStorm.</span></span><br><span class="line"><span class="comment"> * User: helingfeng</span></span><br><span class="line"><span class="comment"> * Date: 2017-11-30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.假设现在有5个顾客的订单记录</span></span><br><span class="line"><span class="comment">// 2.假设支持度min_support=30%</span></span><br><span class="line">$usersNum = <span class="number">5</span>;</span><br><span class="line">$minSupportPercent = <span class="number">0.3</span>;</span><br><span class="line">$minSupport = ceil($minSupportPercent * <span class="number">5</span>);</span><br><span class="line">$ordersForGoods = [</span><br><span class="line">    [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>],</span><br><span class="line">    [<span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>],</span><br><span class="line">    [<span class="string">'A'</span>, <span class="string">'C'</span>],</span><br><span class="line">    [<span class="string">'B'</span>, <span class="string">'C'</span>],</span><br><span class="line">    [<span class="string">'E'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>],</span><br><span class="line">];</span><br><span class="line">$GLOBALS[<span class="string">'combineSets'</span>] = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排列组合</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">combine</span><span class="params">($source = [], $num = <span class="number">0</span>, $target = [])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($num == count($target)) &#123;</span><br><span class="line">        array_push($GLOBALS[<span class="string">'combineSets'</span>], $target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">foreach</span> ($source <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">            $g = $target;</span><br><span class="line">            $b = $source;</span><br><span class="line">            array_push($g, $value);</span><br><span class="line">            $b = array_slice($b, $key + <span class="number">1</span>);</span><br><span class="line">            combine($b, $num, $g);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持度过滤</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filterBySupport</span><span class="params">($orders, $sets, $support)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $nSets = [];</span><br><span class="line">    <span class="keyword">foreach</span> ($sets <span class="keyword">as</span> $items) &#123;</span><br><span class="line">        $min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">foreach</span> ($orders <span class="keyword">as</span> $order) &#123;</span><br><span class="line">            <span class="keyword">if</span> (validSubSets($order, $items)) &#123;</span><br><span class="line">                $min++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ($min &gt;= $support) &#123;</span><br><span class="line">            array_push($nSets, [$items, $min]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $nSets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//频繁项判断</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validSubSets</span><span class="params">($sets, $subSets)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $valid = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">foreach</span> ($subSets <span class="keyword">as</span> $item) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span> === array_search($item, $sets)) &#123;</span><br><span class="line">            $valid = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $valid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取k1项集</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGoodsArr</span><span class="params">($orders)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $goodsArr = [];</span><br><span class="line">    <span class="keyword">foreach</span> ($orders <span class="keyword">as</span> $order) &#123;</span><br><span class="line">        <span class="keyword">foreach</span> ($order <span class="keyword">as</span> $goods) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">false</span> === array_search($goods, $goodsArr)) &#123;</span><br><span class="line">                array_push($goodsArr, $goods);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $goodsArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dimension = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    $goods = getGoodsArr($ordersForGoods);</span><br><span class="line">    combine($goods, $dimension);</span><br><span class="line">    $sets = filterBySupport($ordersForGoods, $GLOBALS[<span class="string">'combineSets'</span>], $minSupport);</span><br><span class="line"><span class="comment">//若集合为空，结束循环</span></span><br><span class="line">    <span class="keyword">if</span> (count($sets) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ($dimension != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> json_encode($sets, JSON_UNESCAPED_UNICODE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">$GLOBALS[<span class="string">'combineSets'</span>] = [];</span><br><span class="line">    $dimension++;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//output 结果</span></span><br><span class="line">[[[<span class="string">"A"</span>,<span class="string">"C"</span>],<span class="number">2</span>],[[<span class="string">"B"</span>,<span class="string">"C"</span>],<span class="number">3</span>],[[<span class="string">"C"</span>,<span class="string">"D"</span>],<span class="number">2</span>]]</span><br></pre></td></tr></table></figure><blockquote><p>代码下载地址： <a href="http://wiki.helingfeng.com/docs/show/4" target="_blank" rel="noopener">http://wiki.helingfeng.com/docs/show/4</a></p></blockquote><h4 id="FPTree算法"><a href="#FPTree算法" class="headerlink" title="FPTree算法"></a><strong>FPTree算法</strong></h4><ul><li><p><strong>算法原理讲解</strong><br>Apriori算法虽然实现简单，但是从算法的效率来看，每次迭代都需要重复遍历，对<code>I\O</code>的资源消耗是巨大的。而基于Apriori改进的FPTree算法，使用<code>树结构</code>进行巧妙临时存储，<code>无论多少数据，只需要扫描两次数据集</code>。</p></li><li><p><strong>基本概念</strong></p><ul><li><code>表头项</code> 记录了所有的事件频繁集出现的次数，并删除支持度低于阈值的项按照次数降序排列。</li><li><code>FPTree</code> 频繁聚项会在树结构体现出重叠。</li></ul></li><li><p><strong>构建FPTree</strong><br>这个是算法就重点的部分。<br>还是举一个例子来分析如何构建吧！</p></li></ul><p>假设支持度support=30%<br>顾客还是那五个演员，哈哈</p><table><thead><tr><th>顾客名称</th><th>订单商品列表</th></tr></thead><tbody><tr><td>张三</td><td>A B C</td></tr><tr><td>李四</td><td>B C D</td></tr><tr><td>王五</td><td>A C</td></tr><tr><td>老六</td><td>B C</td></tr><tr><td>陈七</td><td>E C D</td></tr></tbody></table><p>a.第一次扫描所有数据，得到下面表格；商品=&gt;购买次数</p><table><thead><tr><th>项</th><th>支持度</th></tr></thead><tbody><tr><td>A</td><td>2</td></tr><tr><td>B</td><td>3</td></tr><tr><td>C</td><td>5</td></tr><tr><td>D</td><td>2</td></tr><tr><td>E</td><td>1</td></tr></tbody></table><p>b.按支持度降序排序，并过滤MinSupport，得到表头项</p><table><thead><tr><th>项</th><th>支持度</th></tr></thead><tbody><tr><td>C</td><td>5</td></tr><tr><td>B</td><td>3</td></tr><tr><td>A</td><td>2</td></tr><tr><td>D</td><td>2</td></tr></tbody></table><p>c.根据表头项重新排序订单数据，并过滤，得到新的订单商品列表，如下</p><table><thead><tr><th>顾客名称</th><th>订单商品列表</th></tr></thead><tbody><tr><td>张三</td><td>C B A</td></tr><tr><td>李四</td><td>C B D</td></tr><tr><td>王五</td><td>C A</td></tr><tr><td>老六</td><td>C B</td></tr><tr><td>陈七</td><td>C D</td></tr></tbody></table><p>d.第二次扫描所有数据</p><p>从张三开始，生成树链图t1</p><p><strong>| 张三  | C B A |</strong></p><p><img src="/images/pasted-16.png" alt="upload successful"></p><hr><p><strong>| 李四  | C B D |</strong></p><p><img src="/images/pasted-17.png" alt="upload successful"></p><hr><p><strong>| 王五  | C A |</strong></p><p><img src="/images/pasted-18.png" alt="upload successful"></p><hr><p><strong>| 老六  | C B |</strong></p><p><img src="/images/pasted-19.png" alt="upload successful"></p><hr><p><strong>| 陈七  | C D |</strong></p><p><img src="/images/pasted-20.png" alt="upload successful"></p><hr><p>perfect !</p><p>扫描完数据，FP Tree已经构建完毕。</p><h4 id="挖掘频繁项"><a href="#挖掘频繁项" class="headerlink" title="挖掘频繁项"></a>挖掘频繁项</h4><p>费力九牛之力，终于把Tree构造完成。接下去我们怎么去挖掘频繁项呢？<br>…..思考十五分</p><p>引用文献的一段话，我觉得解释的挺好，<code>大概原理</code>，我们首先要从项头表的底部项依次向上挖掘。对于项头表对应于FP树的每一项，我们要找到它的条件模式基。所谓条件模式基是以我们<strong>要挖掘的节点作为叶子节点</strong>所对应的FP子树。得到这个FP子树，我们将<strong>子树中每个节点的的计数设置为叶子节点的计数</strong>，并<strong>删除计数低于支持度的节点</strong>。从这个条件模式基，我们就可以递归挖掘得到频繁项集了。</p><p>再看看表头项顺序</p><table><thead><tr><th>项</th><th>支持度</th></tr></thead><tbody><tr><td>C</td><td>5</td></tr><tr><td>B</td><td>3</td></tr><tr><td>A</td><td>2</td></tr><tr><td>D</td><td>2</td></tr></tbody></table><p><strong>依次从 D=&gt;A=&gt;B=&gt;C 拆解频繁树，通过minSupport过滤得到频繁项</strong></p><ol><li>首先，拆解D得到两个候选频繁项{C:2,D:2},{C:1,B:1,D:1}；跟据候选项迭代生成FP-tree，最后得到频繁项{C:2,D:2}</li><li>其次，拆解A得到两个候选频繁项{C:2,A:2},{C:1,B:1,A:1}；跟据候选项迭代生成FP-tree，最后得到频繁项{C:2,A:2}</li><li>再次，拆解B得到两个候选频繁项{C:3,B:3}；；跟据候选项迭代生成FP-tree，最后得到频繁项{C:3,B:3}</li><li>最后，C就不需要拆解了；</li></ol><p><strong>FPTree算法最后得到频繁项集</strong><br>{C:3,B:3},{C:2,D:2},{C:2,A:2}</p><p>源代码正在编写中，后面学习章节补上….</p><blockquote><p>平凡之路也会有不平凡的机遇</p></blockquote><blockquote><p>希望大家看完我的文章能有所收获，这就是我的最大荣幸！！！</p></blockquote><h2 id="参考文献，感谢作者"><a href="#参考文献，感谢作者" class="headerlink" title="参考文献，感谢作者"></a>参考文献，感谢作者</h2><ul><li><a href="http://www.cnblogs.com/pinard/p/6293298.html" target="_blank" rel="noopener">http://www.cnblogs.com/pinard/p/6293298.html</a></li><li><a href="https://www.cnblogs.com/zhengxingpeng/p/6679280.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhengxingpeng/p/6679280.html</a></li><li>《数据挖掘算法导论》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;时代的变迁&quot;&gt;&lt;a href=&quot;#时代的变迁&quot; class=&quot;headerlink&quot; title=&quot;时代的变迁&quot;&gt;&lt;/a&gt;时代的变迁&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;曾经我听一个外国人说过这样一句话，翻译过来是这样的意思：&lt;code&gt;程序员&lt;/code&gt;就好比&lt;code
      
    
    </summary>
    
      <category term="算法" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>终端神器 oh my zsh</title>
    <link href="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/2018-08-02/terminal-artifact-oh-my-zsh/"/>
    <id>https://xuehui.我爱你/2018-08-02/terminal-artifact-oh-my-zsh/</id>
    <published>2018-08-02T07:56:00.000Z</published>
    <updated>2018-11-06T13:10:47.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="优化命令终端-oh-my-zsh"><a href="#优化命令终端-oh-my-zsh" class="headerlink" title="优化命令终端 oh my zsh"></a>优化命令终端 oh my zsh</h2><h4 id="oh-my-zsh-配置-zsh-而生"><a href="#oh-my-zsh-配置-zsh-而生" class="headerlink" title="oh my zsh 配置 zsh 而生"></a>oh my zsh 配置 zsh 而生</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># ubuntu 所有 shells</span><br><span class="line"># /etc/shells: valid login shells</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/dash</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/rbash</span><br><span class="line">/usr/bin/tmux</span><br><span class="line">/bin/zsh</span><br><span class="line">/usr/bin/zsh</span><br></pre></td></tr></table></figure><ul><li>oh my zsh 配置0门槛</li><li>完全兼容 bash</li></ul><h4 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh my zsh"></a>安装 oh my zsh</h4><p>Github地址：<a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh</a></p><p>安装命令：</p><ul><li>通过curl自动安装，运行下面命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"</span><br></pre></td></tr></table></figure><ul><li>通过wget自动安装，运行下面命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"</span><br></pre></td></tr></table></figure><hr><h4 id="定制化-zshrc-配置"><a href="#定制化-zshrc-配置" class="headerlink" title="定制化 .zshrc 配置"></a>定制化 .zshrc 配置</h4><ul><li>打开配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd </span><br><span class="line">vim .zshrc</span><br></pre></td></tr></table></figure><ul><li>配置主题</li></ul><p>;# Set name of the theme to load. Optionally, if you set this to “random”<br>;# it’ll load a random theme each time that oh-my-zsh is loaded.<br>;# See <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/wiki/Themes</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME="robbyrussell"</span><br></pre></td></tr></table></figure><ul><li>安装插件</li></ul><p>;# Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)<br>;# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/<br>;# Example format: plugins=(rails git textmate ruby lighthouse)<br>;# Add wisely, as too many plugins slow down shell startup.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins=(git)</span><br><span class="line">plugins=(zsh-autosuggestions)</span><br><span class="line">source $ZSH/oh-my-zsh.sh</span><br></pre></td></tr></table></figure><h4 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h4><ul><li>zsh-syntax-highlighting 语法高亮<br><a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener">https://github.com/zsh-users/zsh-syntax-highlighting</a></li><li>zsh-autosuggestions 命令提示<br><a href="https://github.com/zsh-users/zsh-autosuggestions" target="_blank" rel="noopener">https://github.com/zsh-users/zsh-autosuggestions</a></li></ul><h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p><img src="/images/pasted-15.png" alt="upload successful"></p><blockquote><p>工具让开发变得更简单</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;优化命令终端-oh-my-zsh&quot;&gt;&lt;a href=&quot;#优化命令终端-oh-my-zsh&quot; class=&quot;headerlink&quot; title=&quot;优化命令终端 oh my zsh&quot;&gt;&lt;/a&gt;优化命令终端 oh my zsh&lt;/h2&gt;&lt;h4 id=&quot;oh-my-zsh
      
    
    </summary>
    
      <category term="Linux" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>设计原则集合与使用频率</title>
    <link href="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/2018-07-12/design-principle-collection-and-frequency-of-use/"/>
    <id>https://xuehui.我爱你/2018-07-12/design-principle-collection-and-frequency-of-use/</id>
    <published>2018-07-12T07:38:00.000Z</published>
    <updated>2018-11-06T13:10:19.997Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>设计原则名称</th><th>定  义</th><th>使用频率</th></tr></thead><tbody><tr><td>单一职责原则(Single Responsibility Principle, SRP)</td><td>一个类只负责一个功能领域中的相应职责</td><td>★★★★☆</td></tr><tr><td>开闭原则(Open-Closed Principle, OCP)</td><td>软件实体应对扩展开放，而对修改关闭</td><td>★★★★★</td></tr><tr><td>里氏代换原则(Liskov Substitution Principle, LSP)</td><td>所有引用基类对象的地方能够透明地使用其子类的对象</td><td>★★★★★</td></tr><tr><td>依赖倒转原则(Dependence  Inversion Principle, DIP)</td><td>抽象不应该依赖于细节，细节应该依赖于抽象</td><td>★★★★★</td></tr><tr><td>接口隔离原则(Interface Segregation Principle, ISP)</td><td>使用多个专门的接口，而不使用单一的总接口</td><td>★★☆☆☆</td></tr><tr><td>合成复用原则(Composite Reuse Principle, CRP)</td><td>尽量使用对象组合，而不是继承来达到复用的目的</td><td>★★★★☆</td></tr><tr><td>迪米特法则(Law of Demeter, LoD)</td><td>一个软件实体应当尽可能少地与其他实体发生相互作用</td><td>★★★☆☆</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;设计原则名称&lt;/th&gt;
&lt;th&gt;定  义&lt;/th&gt;
&lt;th&gt;使用频率&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;单一职责原则(Single Responsibility Principle, SRP
      
    
    </summary>
    
      <category term="设计模式" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>基于搬瓦工的翻墙 VPS 搭建</title>
    <link href="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/2018-07-10/based-on-the-wallmoving-work-of-bricklayer-vps/"/>
    <id>https://xuehui.我爱你/2018-07-10/based-on-the-wallmoving-work-of-bricklayer-vps/</id>
    <published>2018-07-10T11:12:00.000Z</published>
    <updated>2018-11-06T13:06:57.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="购买一台外国的-VPS-服务器"><a href="#购买一台外国的-VPS-服务器" class="headerlink" title="购买一台外国的 VPS 服务器"></a>购买一台外国的 VPS 服务器</h2><p>板瓦工，许多人的选择，稳定经济，最重要的是支持”支付宝支付”</p><ul><li><a href="https://bandwagonhost.com/aff.php?aff=25516" target="_blank" rel="noopener">https://bandwagonhost.com/aff.php?aff=25516</a></li><li><a href="https://www.bwh1.net/aff.php?aff=25516" target="_blank" rel="noopener">https://www.bwh1.net/aff.php?aff=25516</a></li></ul><p>第一个链接可能需要翻墙才能访问。<br>进入网站后，自己挑选一款服务器，价格都很实惠，最便宜的好像19美元一年。</p><h2 id="安装-Shadowsocks-Server"><a href="#安装-Shadowsocks-Server" class="headerlink" title="安装 Shadowsocks Server"></a>安装 Shadowsocks Server</h2><p>进入 VPS 的 KiwiNM Control Panel 界面</p><p><img src="/images/screen_20.png" alt="vps"> </p><p> 点击一键安装即可, 得到 Shadowsocks Server 的端口和密码以及加密方式</p><h2 id="安装-Shadowsocks-客户端"><a href="#安装-Shadowsocks-客户端" class="headerlink" title="安装 Shadowsocks 客户端"></a>安装 Shadowsocks 客户端</h2><p> 百度搜一下，随便下载，配置服务器信息，就可以进行代理了。</p><p> <img src="/images/screen_21.png" alt="vps"> </p><p> 注意，Linux 环境下，需要安装 Chrome 插件</p><h2 id="访问-Google"><a href="#访问-Google" class="headerlink" title="访问 Google"></a>访问 Google</h2><p>  <img src="/images/screen_22.png" alt="vps"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;购买一台外国的-VPS-服务器&quot;&gt;&lt;a href=&quot;#购买一台外国的-VPS-服务器&quot; class=&quot;headerlink&quot; title=&quot;购买一台外国的 VPS 服务器&quot;&gt;&lt;/a&gt;购买一台外国的 VPS 服务器&lt;/h2&gt;&lt;p&gt;板瓦工，许多人的选择，稳定经济，最重
      
    
    </summary>
    
      <category term="VPS" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/categories/VPS/"/>
    
    
      <category term="VPS" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/VPS/"/>
    
  </entry>
  
  <entry>
    <title>程序员进阶读书推荐</title>
    <link href="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/2018-07-08/programmer-advanced-reading-recommendation/"/>
    <id>https://xuehui.我爱你/2018-07-08/programmer-advanced-reading-recommendation/</id>
    <published>2018-07-08T13:22:00.000Z</published>
    <updated>2018-11-06T13:09:33.105Z</updated>
    
    <content type="html"><![CDATA[<h3 id="求知若渴-stay-hungry-stay-foolish"><a href="#求知若渴-stay-hungry-stay-foolish" class="headerlink" title="求知若渴 stay hungry,stay foolish"></a>求知若渴 stay hungry,stay foolish</h3><p>阅读是获取技能理论最简洁且最有效的方式之一，阅读是一种享受<br>每周抽出一点时间，安静坐下来，打开一本书<br>我们常常听到这样一句话“时间就是金钱”，我个人对这句话的理解是，时间它不停的流逝，我们没有办法去改变时间的长短，我们所能做的就是利用有限的时间去做那些我们认为更有价值或更有意义的事。而我觉得“阅读就是一件挺有意义的事”。</p><h3 id="推荐编程技能经典书籍"><a href="#推荐编程技能经典书籍" class="headerlink" title="推荐编程技能经典书籍"></a>推荐编程技能经典书籍</h3><h4 id="WEB前端开发"><a href="#WEB前端开发" class="headerlink" title="WEB前端开发"></a>WEB前端开发</h4><ul><li><p><strong>《HTTP权威指南》</strong>该书分为五部分，分别讲述Web基础知识，HTTP结构，识别/验证与安全，实体/编码和国际化，及内容发布与分发。介绍HTTP协议，详细描述Web网络资源URL/URI，并介绍HTTP是如何传输报文；介绍了Web服务器结构，深入代理服务器研究，缓存及应用服务器的作用，还介绍Web服务的各种客户端，包括浏览器爬虫等；研究HTTP身份识别与验证，讨论SSL等安全性问题；详细讲解HTTP内容结构，规范编码，多语言问题；最后探讨Web服务托管，Web服务流量分散等问题。</p><blockquote><p>百度网盘下载 <a href="https://pan.baidu.com/s/1o8dxz7c" target="_blank" rel="noopener">https://pan.baidu.com/s/1o8dxz7c</a></p></blockquote></li><li><p><strong>《JavaScript权威指南》</strong>讲解JavaScript基础语法，及数据结构；讨论了服务器端的JavaScript与客户端的JavaScript，详细讲解Window对象，正则表达式，函数，事件处理；深入客户端缓存，及HTML5 API；讨论相关的JavaScript类库，如JQuery。</p><blockquote><p>百度网盘下载 <a href="https://pan.baidu.com/s/1pKKyEoj" target="_blank" rel="noopener">https://pan.baidu.com/s/1pKKyEoj</a></p></blockquote></li></ul><h4 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h4><ul><li><p><strong>《算法导论》</strong>我认为是最经典的算法书籍，无论阅读者能力高低，都能从中汲取许多想法或思路，对技能的成长具有深远的影响。</p><blockquote><p>百度网盘下载 <a href="https://pan.baidu.com/s/1i48zDkh" target="_blank" rel="noopener">https://pan.baidu.com/s/1i48zDkh</a></p></blockquote></li><li><p><strong>《程序员实用算法》</strong>是算法导论的简洁版本，针对开发人员工作常见问题的算法解决方案总结。算法复杂度，排序，查找，压缩，树结构，时间与日期处理，数据校验等知识点。</p><blockquote><p>百度网盘下载 <a href="https://pan.baidu.com/s/1eSs6U0U" target="_blank" rel="noopener">https://pan.baidu.com/s/1eSs6U0U</a></p></blockquote></li><li><p><strong>《设计模式》</strong>本书设计实例从面向对象的设计中精选出 23 个设计模式,总结了面向对象设计中最有价值的经验,并且用简洁可复用的形式表达出来。本书分类描述了一组设计良好,表达清楚的软件设计模式,这些模式在实用环境下有特别有用。</p><blockquote><p>百度网盘下载 <a href="https://pan.baidu.com/s/1eS4coYQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1eS4coYQ</a></p></blockquote></li></ul><h4 id="数据库与服务器"><a href="#数据库与服务器" class="headerlink" title="数据库与服务器"></a>数据库与服务器</h4><p>手册在手，代码我有</p><ul><li><p><strong>《MySQL_5.5中文参考手册》</strong></p><blockquote><p>百度网盘下载 <a href="https://pan.baidu.com/s/1pLokQQf" target="_blank" rel="noopener">https://pan.baidu.com/s/1pLokQQf</a></p></blockquote></li><li><p><strong>《MySQL核心技术手册(第二版)》</strong></p><blockquote><p>百度网盘下载 <a href="https://pan.baidu.com/s/1sluSqN7" target="_blank" rel="noopener">https://pan.baidu.com/s/1sluSqN7</a></p></blockquote></li><li><p><strong>《Nginx HTTP Server中文版》</strong></p><blockquote><p>百度网盘下载 <a href="https://pan.baidu.com/s/1hsQsKAg" target="_blank" rel="noopener">https://pan.baidu.com/s/1hsQsKAg</a></p></blockquote></li><li><p><strong>《Linux命令速查手册》</strong></p><blockquote><p>百度网盘下载 <a href="https://pan.baidu.com/s/1hsBzHVA" target="_blank" rel="noopener">https://pan.baidu.com/s/1hsBzHVA</a></p></blockquote></li></ul><h4 id="Google大数据三大论文经典"><a href="#Google大数据三大论文经典" class="headerlink" title="Google大数据三大论文经典"></a>Google大数据三大论文<code>经典</code></h4><p>开启你的大数据学习之门</p><ul><li><p><strong>《Google技术之_Mapreduce中文版》</strong></p><blockquote><p>百度网盘下载 <a href="https://pan.baidu.com/s/1c8ohVC" target="_blank" rel="noopener">https://pan.baidu.com/s/1c8ohVC</a></p></blockquote></li><li><p><strong>《Google技术之_GFS中文版》</strong></p><blockquote><p>百度网盘下载 <a href="https://pan.baidu.com/s/1gfF519h" target="_blank" rel="noopener">https://pan.baidu.com/s/1gfF519h</a></p></blockquote></li><li><p><strong>《Google技术之_BigTable中文版》</strong></p><blockquote><p>百度网盘下载 <a href="https://pan.baidu.com/s/1hr6zEFq" target="_blank" rel="noopener">https://pan.baidu.com/s/1hr6zEFq</a></p></blockquote></li></ul><h4 id="其他阅读"><a href="#其他阅读" class="headerlink" title="其他阅读"></a>其他阅读</h4><ul><li><p><strong>《web前端黑客技术揭秘》</strong></p><blockquote><p>百度网盘下载 <a href="https://pan.baidu.com/s/1mi7TLHm" target="_blank" rel="noopener">https://pan.baidu.com/s/1mi7TLHm</a></p></blockquote></li><li><p><strong>《编写高质量代码–Web前端开发修炼之道》</strong></p><blockquote><p>百度网盘下载 <a href="https://pan.baidu.com/s/1geDnwrh" target="_blank" rel="noopener">https://pan.baidu.com/s/1geDnwrh</a></p></blockquote></li><li><p><strong>《JavaScript高级程序设计》</strong></p><blockquote><p>百度网盘下载 <a href="https://pan.baidu.com/s/1jH9J22y" target="_blank" rel="noopener">https://pan.baidu.com/s/1jH9J22y</a></p></blockquote></li><li><p><strong>《番茄工作法图解：简单易行的时间管理方法》</strong></p><blockquote><p>百度网盘下载 <a href="https://pan.baidu.com/s/1hr7fHZI" target="_blank" rel="noopener">https://pan.baidu.com/s/1hr7fHZI</a></p></blockquote></li><li><p><strong>《程序员面试金典（第5版）》</strong></p><blockquote><p>百度网盘下载 <a href="https://pan.baidu.com/s/1skOyrAd" target="_blank" rel="noopener">https://pan.baidu.com/s/1skOyrAd</a></p></blockquote></li><li><p><strong>《人月神话》</strong>软件开发项目工时计算与管理书籍</p><blockquote><p>百度网盘下载 <a href="https://pan.baidu.com/s/1kVzOqBd" target="_blank" rel="noopener">https://pan.baidu.com/s/1kVzOqBd</a></p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;求知若渴-stay-hungry-stay-foolish&quot;&gt;&lt;a href=&quot;#求知若渴-stay-hungry-stay-foolish&quot; class=&quot;headerlink&quot; title=&quot;求知若渴 stay hungry,stay foolish&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="读书" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读书" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>如何建设高可用系统</title>
    <link href="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/2018-06-21/how-to-build-a-highly-available-system/"/>
    <id>https://xuehui.我爱你/2018-06-21/how-to-build-a-highly-available-system/</id>
    <published>2018-06-21T06:12:00.000Z</published>
    <updated>2018-11-06T13:07:27.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高可用性设计建议"><a href="#高可用性设计建议" class="headerlink" title="高可用性设计建议"></a>高可用性设计建议</h2><p>“高可用性”（High Availability）通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性。以下是高可用系统的设计建议：</p><h4 id="减少单点"><a href="#减少单点" class="headerlink" title="减少单点"></a>减少单点</h4><p>去单点首先要识别整个系统所有主链路的单点，如机房（同城异地双机房），应用服务器，DNS服务器，SFTP服务器，LBS，缓存服务器，数据库，消息服务器，代理服务器和专线等，如系统通过专线调用对方服务，需要考虑同时拉联通和电信的专线，联通或电信的专线还是有一定概率会出现问题的，但是同时出问题的概率会小非常多。优先使用软负载，使用硬负载兜底。</p><h4 id="减少依赖"><a href="#减少依赖" class="headerlink" title="减少依赖"></a>减少依赖</h4><p>减少DNS依赖，减少远程服务依赖，DNS依赖可以尝试设置本地host，用工具给所有服务器推送最新的域名映射关系，通过本地缓存或近端服务减少RPC调用。</p><h4 id="限制循环"><a href="#限制循环" class="headerlink" title="限制循环"></a>限制循环</h4><p>避免无限死循环，导致CPU利用率百分百，可以设置for循环的最大循环次数，如最大循环1000次。</p><h4 id="控制流量"><a href="#控制流量" class="headerlink" title="控制流量"></a>控制流量</h4><p>避免异常流量对应用服务器产生影响，可以对指定服务设置流量限制，如QPS，TPS，QPH（每小时总请求量）和QPD（每天总请求量）。</p><h4 id="精准监控"><a href="#精准监控" class="headerlink" title="精准监控"></a>精准监控</h4><p>对CPU利用率，load，内存，带宽，系统调用量，应用错误量，PV，UV和业务量进行监控，避免内存泄露和异常代码对系统产生影响，配置监控一定要精准，如平时内存利用率是50%，监控可以配置成60%进行报警，这样可以提前感知内存泄露问题，避免应用无响应。</p><h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>服务器不能保存用户状态数据，如在集群环境下不能用static变量保存用户数据，不能长时间把用户文件存放在服务器本地。服务器有状态会难以扩容，且出现单点问题。</p><h4 id="容量规划"><a href="#容量规划" class="headerlink" title="容量规划"></a>容量规划</h4><p>定期对容量进行评估。如大促前进行压测和容量预估，根据需要进行扩容。</p><h4 id="功能开关"><a href="#功能开关" class="headerlink" title="功能开关"></a>功能开关</h4><p>打开和关闭某些功能，比如消息量过大，系统处理不了，把开关打开后直接丢弃消息不处理。上线新功能增加开关，如果有问题关闭新功能。</p><h4 id="设置超时"><a href="#设置超时" class="headerlink" title="设置超时"></a>设置超时</h4><p>设置连接超时和读超时设置，不应该太大，如果是内部调用连接超时可以设置成1秒，读超时3秒，外部系统调用连接超时可以设置成3秒，读超时设置成20秒。</p><h4 id="重试策略"><a href="#重试策略" class="headerlink" title="重试策略"></a>重试策略</h4><p>当调用外部服务异常时可以设置重试策略，每次重试时间递增，但是需要设置最大重试次数和重试开关，避免对下游系统产生影响。</p><h4 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h4><p>应用隔离，模块隔离，机房隔离和线程池隔离。可以按照优先级，不变和变几个维度来隔离应用和模块，如抽象和不变的代码放在一个模块，这个模块的代码几乎不会修改，可用性高，经常变的业务逻辑放在一个模块里，这样就算有问题，也只会影响到某一个业务。不同的业务使用不同的线程池，避免低优先级任务阻塞高优先级，或高优先级任务过多时影响低优先级任务永远不会执行。 </p><h4 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h4><p>同步调用改成异步调用，解决远程调用故障或调用超时对系统的影响。</p><h4 id="热点缓存"><a href="#热点缓存" class="headerlink" title="热点缓存"></a>热点缓存</h4><p>对热点数据进行缓存，降低RPC调用。如B系统提供名单服务，B系统可以提供一个client SDK提供近端缓存服务，定期去服务器端取数据，减少RPC调用。</p><h4 id="缓存容灾"><a href="#缓存容灾" class="headerlink" title="缓存容灾"></a>缓存容灾</h4><p>当数据库不可用时可以使用缓存的数据。并设置分级缓存，如优先读本地缓存，其次读分布式缓存。</p><h4 id="分级缓存"><a href="#分级缓存" class="headerlink" title="分级缓存"></a>分级缓存</h4><p>优先读本地缓存，其次读分布式缓存。通过推模式更新本地缓存。</p><h4 id="系统分级"><a href="#系统分级" class="headerlink" title="系统分级"></a>系统分级</h4><p>对系统进行分级，如ABC三个等级，高级别系统不依赖于低级别系统，并且高级别系统比底级别系统高可用率要高。</p><h4 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h4><p>如果系统出现响应缓慢等状况，可以关闭部分功能，从而释放系统资源，保证核心服务的正常运行。需要识别哪些服务可以降级，比如突然有大量消息流入，导致服务不可用，我们会把消息直接丢弃掉。或通过设置流控，拒绝为低级别系统提供服务。</p><h4 id="流量蓄洪"><a href="#流量蓄洪" class="headerlink" title="流量蓄洪"></a>流量蓄洪</h4><p>当流量陡增时，可以将请求进行蓄洪，如把请求保存在数据库中，再按照指定的QPS进行泄洪，有效的保护下游系统，也保证了服务的可用性。当调用对方系统，对方系统响应缓慢或无响应时，可采取自动蓄洪。</p><h4 id="服务权重"><a href="#服务权重" class="headerlink" title="服务权重"></a>服务权重</h4><p>在集群环境中，可自动识别高性能服务，拒绝调用性能低的服务。如在集群环境中，对调用超时的服务器进行权重降低，优先调用权重高的服务器。</p><h4 id="依赖简化"><a href="#依赖简化" class="headerlink" title="依赖简化"></a>依赖简化</h4><p>减少系统之间的依赖，比如使用消息驱动，A和B系统通过消息服务器传递数据，A和B系统使用数据库进行读写分离，A系统负责往数据库中写数据，B系统负责读数据，因为数据存放在数据库中，当A不可用时，短时间内不影响B系统提供服务。</p><h4 id="弹性扩容"><a href="#弹性扩容" class="headerlink" title="弹性扩容"></a>弹性扩容</h4><p>根据资源的使用率自动或手动进行扩容。如带宽不够用时，快速增加带宽。</p><h4 id="灰度和回滚"><a href="#灰度和回滚" class="headerlink" title="灰度和回滚"></a>灰度和回滚</h4><p>发布新功能只让部分服务器生效，且观察几天逐渐切流，如果出现问题只影响部分客户。出现问题快速回滚，或者直接下线灰度的机器。</p><h4 id="减少远程调用"><a href="#减少远程调用" class="headerlink" title="减少远程调用"></a>减少远程调用</h4><p>优先调用本地JVM内服务，其次是同机房服务，然后是同城服务，最后是跨城服务。如A调用B，B调用互联网的C系统获取数据，B系统可以把数据缓存起来，并设置数据的保鲜度，减少B对C的依赖。配置中心把注册服务的地址推送到调用服务的系统本地。参数中心把参数配置信息推送到系统的本地内存，而不是让系统去远程服务器获取参数信息。</p><h4 id="熔断机制"><a href="#熔断机制" class="headerlink" title="熔断机制"></a>熔断机制</h4><p>增加熔断机制，当监控出线上数据出现大幅跌涨时，及时中断，避免对业务产生更大影响。如我们做指标计算时，指标可以计算慢，但是不能算错，如果发现某个用户的指标环比或同比增长一倍或跌零，会考虑保存所有消息，并中止该用户的指标计算。</p><h4 id="运行时加载模块"><a href="#运行时加载模块" class="headerlink" title="运行时加载模块"></a>运行时加载模块</h4><p>我们会把经常变的业务代码变成一个个业务模块，使用Java的ClassLoader在运行时动态加载和卸载模块，当某个模块有问题时候，可以快速修复。</p><h4 id="代码扫描"><a href="#代码扫描" class="headerlink" title="代码扫描"></a>代码扫描</h4><p>使用IDEA代码分析等工具进行代码扫描，识别出程序中的BUG，如空指针异常，循环依赖等。</p><h4 id="自动备份"><a href="#自动备份" class="headerlink" title="自动备份"></a>自动备份</h4><p>程序，系统配置和数据定期进行备份。可使用linux命令和shell脚本定时执行备份策略，自动进行本地或异地。出现问题时能快速重新部署。</p><h4 id="线上压测"><a href="#线上压测" class="headerlink" title="线上压测"></a>线上压测</h4><p>系统的对外服务需要进行压测，知道该服务能承受的QPS和TPS，从而做出相对准确的限流。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;高可用性设计建议&quot;&gt;&lt;a href=&quot;#高可用性设计建议&quot; class=&quot;headerlink&quot; title=&quot;高可用性设计建议&quot;&gt;&lt;/a&gt;高可用性设计建议&lt;/h2&gt;&lt;p&gt;“高可用性”（High Availability）通常来描述一个系统经过专门的设计，从而减少
      
    
    </summary>
    
      <category term="并发" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="高可用" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>使用 Jenkins 自动化发布 PHP 项目</title>
    <link href="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/2018-06-13/publish-php-projects-with-jenkins-automation/"/>
    <id>https://xuehui.我爱你/2018-06-13/publish-php-projects-with-jenkins-automation/</id>
    <published>2018-06-13T03:12:00.000Z</published>
    <updated>2018-11-06T13:06:54.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Jenkins"><a href="#什么是-Jenkins" class="headerlink" title="什么是 Jenkins"></a>什么是 Jenkins</h2><p>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p><h2 id="使用-Docker-安装-Jenkins"><a href="#使用-Docker-安装-Jenkins" class="headerlink" title="使用 Docker 安装 Jenkins"></a>使用 Docker 安装 Jenkins</h2><p>避免装环境的折腾, 直接使用 docker-compose 安装，具体如何安装在 <code>Docker 快速搭建 LNMP 环境</code> 已经描述了</p><p>docker-compose.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jenkins:</span></span><br><span class="line"><span class="attr">  image:</span> <span class="attr">jenkins:latest</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"8080:8080"</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./jenkins:/var/jenkins_home:rw</span></span><br></pre></td></tr></table></figure><p>注意：volumes 配置 jenkins 目录映射到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 等待下载镜像，创建容器</span><br><span class="line">Creating dnmp_jenkins_1    ... done</span><br><span class="line"><span class="meta">#</span> 安装就这么简单</span><br></pre></td></tr></table></figure><h2 id="访问-8080-端口，进入初始化页面"><a href="#访问-8080-端口，进入初始化页面" class="headerlink" title="访问 8080 端口，进入初始化页面"></a>访问 8080 端口，进入初始化页面</h2><p>访问: <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p><p>首次打开，需要输入秘钥，根据提示，可以在对应的目录 /jenkins/secrets 找到该文件<br>设置登录用户名密码后，进入几分钟的初始化过程…</p><p><img src="/images/screen_5.png" alt="screen"></p><h2 id="配置自动化构建发布"><a href="#配置自动化构建发布" class="headerlink" title="配置自动化构建发布"></a>配置自动化构建发布</h2><h3 id="配置远程服务器-SSH"><a href="#配置远程服务器-SSH" class="headerlink" title="配置远程服务器 SSH"></a>配置远程服务器 SSH</h3><p>菜单 -&gt; 系统管理 -&gt; 系统设置 -&gt;  SSH Servers</p><p><img src="/images/screen_7.png" alt="screen"></p><p>如图，是我配置的内容</p><p><img src="/images/screen_8.png" alt="screen"></p><p>Remote Directory 这个配置很关键，表示构建时的相对目录。这里我配置 “/“<br>配置完成后，最好 Test Configuration , 返回 Success 就表示成功！</p><h3 id="新建发布项目"><a href="#新建发布项目" class="headerlink" title="新建发布项目"></a>新建发布项目</h3><p>填写项目名称如, test<br>并选择项目类型，这里我选择”自由风格项目”<br><img src="/images/screen_6.png" alt="screen"></p><h4 id="General"><a href="#General" class="headerlink" title="General"></a>General</h4><p>选择对应项目路径，我使用 GitHub project </p><p><img src="/images/screen_9.png" alt="screen"></p><h4 id="源码管理"><a href="#源码管理" class="headerlink" title="源码管理"></a>源码管理</h4><p>使用 git 源码仓库管理</p><p><img src="/images/screen_10.png" alt="screen"></p><h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><p>这里是最关键的，你可以打包源码发布到对应的服务器之上</p><p><img src="/images/screen_11.png" alt="screen"></p><ul><li>Source files 表示打包好的源文件</li><li>Remote directory 表示你需要将源文件上传的远程路径（这个路径相对于 SSH 配置目录）</li><li>Exec command 上传完成后，执行的命令（ hexo g 这个是我发布博客时的构建命令）</li></ul><h3 id="立即构建"><a href="#立即构建" class="headerlink" title="立即构建"></a>立即构建</h3><p>选择对应的项目，点击立即构建</p><p><img src="/images/screen_12.png" alt="screen"></p><p>在构建执行状态中，可以点击 console output 看到构建的过程信息</p><p><img src="/images/screen_13.png" alt="screen"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是-Jenkins&quot;&gt;&lt;a href=&quot;#什么是-Jenkins&quot; class=&quot;headerlink&quot; title=&quot;什么是 Jenkins&quot;&gt;&lt;/a&gt;什么是 Jenkins&lt;/h2&gt;&lt;p&gt;Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工
      
    
    </summary>
    
      <category term="Jenkins" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/categories/Jenkins/"/>
    
    
      <category term="Jenkins" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Web浏览器同源政策及其规避方法</title>
    <link href="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/2018-06-12/web-browser-homology-policy-and-its-avoidance-method/"/>
    <id>https://xuehui.我爱你/2018-06-12/web-browser-homology-policy-and-its-avoidance-method/</id>
    <published>2018-06-12T07:41:00.000Z</published>
    <updated>2018-11-06T13:06:35.247Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章参考： <a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" title="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</a></p></blockquote><h2 id="同源政策"><a href="#同源政策" class="headerlink" title="同源政策"></a>同源政策</h2><p>所谓同源，是指<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">协议</span><br><span class="line">域名</span><br><span class="line">端口</span><br></pre></td></tr></table></figure></p><p>当且仅当协议域名端口都相同，才能称作同源。</p><h2 id="限制范围"><a href="#限制范围" class="headerlink" title="限制范围"></a>限制范围</h2><p>非同源情况下，以下操作是受限的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cookie LocalStorage 不能读取</span><br><span class="line">Dom 无法获得</span><br><span class="line">Ajax 不能发送</span><br></pre></td></tr></table></figure><h2 id="政策目的"><a href="#政策目的" class="headerlink" title="政策目的"></a>政策目的</h2><p>同源政策是为了保护用户信息的安全，防止恶意的网站窃取。</p><p>如果Cookie可以共享，用户访问A银行网站，再去访问B网站，那么会发生什么？</p><p>很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置<strong>document.domain</strong>共享 Cookie。</p><h2 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h2><p>如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。</p><p>规避方法</p><ul><li>片段识别符（fragment identifier）</li><li>window.name</li><li>跨文档通信API（Cross-document messaging）</li></ul><h3 id="片段识别符"><a href="#片段识别符" class="headerlink" title="片段识别符"></a>片段识别符</h3><p>片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如<a href="http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。" target="_blank" rel="noopener">http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。</a></p><p>父窗口可以把信息，写入子窗口的片段标识符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var src = originURL + &apos;#&apos; + data;</span><br><span class="line">document.getElementById(&apos;myIFrame&apos;).src = src;</span><br></pre></td></tr></table></figure><p>子窗口通过监听hashchange事件得到通知。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.onhashchange = checkMessage;</span><br><span class="line"></span><br><span class="line">function checkMessage() &#123;</span><br><span class="line">  var message = window.location.hash;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，子窗口也可以改变父窗口的片段标识符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.location.href= target + &quot;#&quot; + hash;</span><br></pre></td></tr></table></figure><h3 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h3><p>浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。</p><p>父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入window.name属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.name = data;</span><br></pre></td></tr></table></figure><p>接着，子窗口跳回一个与主窗口同域的网址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location = &apos;http://parent.url.com/xxx.html&apos;;</span><br></pre></td></tr></table></figure><p>然后，主窗口就可以读取子窗口的window.name了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var data = document.getElementById(&apos;myFrame&apos;).contentWindow.name;</span><br></pre></td></tr></table></figure><p>这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。</p><h3 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a>window.postMessage</h3><p>上面两种方法都属于破解，HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。<br>这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。<br>举例来说，父窗口<a href="http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法就可以了。" target="_blank" rel="noopener">http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法就可以了。</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var popup = window.open(&apos;http://bbb.com&apos;, &apos;title&apos;);</span><br><span class="line">popup.postMessage(&apos;Hello World!&apos;, &apos;http://bbb.com&apos;);</span><br></pre></td></tr></table></figure><p>postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即”协议 + 域名 + 端口”。也可以设为*，表示不限制域名，向所有窗口发送。<br>子窗口向父窗口发送消息的写法类似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.opener.postMessage(&apos;Nice to see you&apos;, &apos;http://aaa.com&apos;);</span><br></pre></td></tr></table></figure><p>父窗口和子窗口都可以通过message事件，监听对方的消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;message&apos;, function(e) &#123;</span><br><span class="line">  console.log(e.data);</span><br><span class="line">&#125;,false);</span><br></pre></td></tr></table></figure><p>message事件的事件对象event，提供以下三个属性。</p><ul><li>event.source：发送消息的窗口</li><li>event.origin: 消息发向的网址</li><li>event.data: 消息内容</li></ul><p>下面的例子是，子窗口通过event.source属性引用父窗口，然后发送消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;message&apos;, receiveMessage);</span><br><span class="line">function receiveMessage(event) &#123;</span><br><span class="line">  event.source.postMessage(&apos;Nice to see you!&apos;, &apos;*&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>event.origin属性可以过滤不是发给本窗口的消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;message&apos;, receiveMessage);</span><br><span class="line">function receiveMessage(event) &#123;</span><br><span class="line">  if (event.origin !== &apos;http://aaa.com&apos;) return;</span><br><span class="line">  if (event.data === &apos;Hello World&apos;) &#123;</span><br><span class="line">      event.source.postMessage(&apos;Hello&apos;, event.origin);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(event.data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h3><p>通过window.postMessage，读写其他窗口的 LocalStorage 也成为了可能。</p><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>同源政策规定，AJAX请求只能发给同源的网址，否则就报错。<br>除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- jsonp</span><br><span class="line">- websocket</span><br><span class="line">- cors</span><br></pre></td></tr></table></figure><h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><p>JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。<br>它的基本思想是，网页通过添加一个<strong>script</strong>元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。<br>首先，网页动态插入<strong>script</strong>元素，由它向跨源网址发出请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function addScriptTag(src) &#123;</span><br><span class="line">  var script = document.createElement(&apos;script&apos;);</span><br><span class="line">  script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);</span><br><span class="line">  script.src = src;</span><br><span class="line">  document.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.onload = function () &#123;</span><br><span class="line">  addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo(data) &#123;</span><br><span class="line">  console.log(&apos;Your public IP address is: &apos; + data.ip);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码通过动态添加<strong>script</strong>元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。<br>服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo(&#123;</span><br><span class="line">  &quot;ip&quot;: &quot;8.8.8.8&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>由于<strong>script</strong>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。</p><h3 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h3><p>WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。<br>下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自维基百科）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http://example.com</span><br></pre></td></tr></table></figure><p>上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。<br>正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;文章参考： &lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html&quot; title=&quot;http://www.ruanyifeng.com/blog/2016/04
      
    
    </summary>
    
      <category term="跨域" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/categories/%E8%B7%A8%E5%9F%9F/"/>
    
    
      <category term="跨域" scheme="https://xuehui.%E6%88%91%E7%88%B1%E4%BD%A0/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
</feed>
