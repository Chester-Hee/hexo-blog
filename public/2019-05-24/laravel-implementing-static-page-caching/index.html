<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="code farmer."><title>Laravel 实现页面静态缓存 | 追赶日落日出</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?66bdd0a984d281716c78a567d1f39e67";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">首页</a><a class="sidebar-nav-item" href="/archives">归档</a><a class="sidebar-nav-item" href="/about">关于我</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Cache/">Cache</a><a class="post-tag-link" href="/tags/Composer/">Composer</a><a class="post-tag-link" href="/tags/Laravel/">Laravel</a><a class="post-tag-link" href="/tags/PHP/">PHP</a></div><div class="post-time">2019-05-24</div></div></div><div class="container post-header"><h1>Laravel 实现页面静态缓存</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#页面静态缓存"><span class="toc-number">1.</span> <span class="toc-text">页面静态缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Laravel-页面静态缓存"><span class="toc-number">2.</span> <span class="toc-text">Laravel 页面静态缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现思路"><span class="toc-number">2.1.</span> <span class="toc-text">实现思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分布式支持"><span class="toc-number">2.2.</span> <span class="toc-text">分布式支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更新缓存"><span class="toc-number">2.3.</span> <span class="toc-text">更新缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#思考？"><span class="toc-number">2.4.</span> <span class="toc-text">思考？</span></a></li></ol></li></ol></details></div><div class="container post-content"><h2 id="页面静态缓存"><a href="#页面静态缓存" class="headerlink" title="页面静态缓存"></a>页面静态缓存</h2><p>页面缓存就是在用户访问页面时，直接返回静态文件，减少了每次请求的业务处理和模板渲染，从而提高网站的<code>QPS</code>。在许多实时性要求不高的场景，或者纯查询和展示数据的页面，添加静态页面缓存并合理的配置缓存有效期可以有效的提升网站性能。</p>
<h2 id="Laravel-页面静态缓存"><a href="#Laravel-页面静态缓存" class="headerlink" title="Laravel 页面静态缓存"></a>Laravel 页面静态缓存</h2><p>附上代码地址：<a href="https://github.com/freedoomcode/laravel-page-cache" target="_blank" rel="noopener">https://github.com/freedoomcode/laravel-page-cache</a></p>
<p>我编码功底有限，希望你可以舍得给予建议</p>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ul>
<li>对于请求前后的处理，我们想到的是中间件（请求过滤器）</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">($request, Closure $next, $guard = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 请求之前处理</span></span><br><span class="line">    $response = $next($request);</span><br><span class="line">    <span class="comment">// 请求之后处理</span></span><br><span class="line">    <span class="keyword">return</span> $response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>请求之前，我们对请求参数<code>path</code>+<code>query</code>进行编码作为文件名</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$fileName = md5($uri);</span><br></pre></td></tr></table></figure>
<ul>
<li>并使用此文件名搜索是否存在文件，如果文件存在，若存在直接读取返回</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$fileName = <span class="keyword">$this</span>-&gt;getRealFileNameByPath($request-&gt;getRequestUri());</span><br><span class="line"><span class="keyword">if</span> (is_file($fileName)) &#123;</span><br><span class="line">    <span class="keyword">return</span> response(file_get_contents($fileName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>若不存在则将当期页面的响应内容写入文件，为了确保内容正确，判断响应状态码是否为<code>200</code>。并对正在写入的文件进行加锁。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ($response-&gt;getStatusCode() == <span class="number">200</span>) &#123;</span><br><span class="line">    $content = $response-&gt;getContent();</span><br><span class="line">    <span class="keyword">if</span> (!is_file($fileName)) &#123;</span><br><span class="line">        file_put_contents($fileName, $content, LOCK_EX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分布式支持"><a href="#分布式支持" class="headerlink" title="分布式支持"></a>分布式支持</h3><p>起初，我想将整个页面文档存入<code>Redis</code>中，但测试发现导致<code>Redis</code>网络占用非常高，因为单个页面大小为<code>100K+</code>，同时访问将会不断读取<code>Redis</code>。最后，我将页面保存在服务器文件中。</p>
<p>但是，如果存在多台服务器，那么如何统一更新页面缓存呢？所以还需要共享一个键值，我将这个键值存储在<code>Redis</code>中，这个键值相当于每个服务存储静态文件的所在路径。更新这个键值就相当于更新文件所在路径。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$key = env(<span class="string">'STATIC_HTML_CACHE_DIR_KEY'</span>, <span class="string">'static_html_directory'</span>);</span><br><span class="line">$expires = env(<span class="string">'STATIC_HTML_CACHE_EXPIRE'</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span>(Cache::has($key)) &#123;</span><br><span class="line">    $directory = Cache::get($key, date(<span class="string">'YmdHis'</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $directory = date(<span class="string">'YmdHis'</span>);</span><br><span class="line">    Cache::put($key, $directory, $expires);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 完整的路径为 storage + directory</span></span><br><span class="line">$fullPath = $prefix . DIRECTORY_SEPARATOR . $directory;</span><br></pre></td></tr></table></figure>
<p>将文件存储在每台服务器中，均衡负载的压力，如果可以将静态文件存储在内存中，效果会更佳，使用<code>Swoole</code>应该可以实现。</p>
<h3 id="更新缓存"><a href="#更新缓存" class="headerlink" title="更新缓存"></a>更新缓存</h3><p>刷新指定<code>Redis</code>键值即可<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache::put($key, date(<span class="string">'YmdHis'</span>), $expires);</span><br></pre></td></tr></table></figure></p>
<h3 id="思考？"><a href="#思考？" class="headerlink" title="思考？"></a>思考？</h3><p>这种思路，只适合小产品，可能还会存在其他的问题，所以需要慎用。不过，敢于尝试才会懂得！</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>